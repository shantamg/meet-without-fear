---
phase: 05-stage-transition-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mobile/src/screens/UnifiedSessionScreen.tsx
  - backend/src/controllers/stage2.ts
  - backend/src/controllers/sessions.ts
autonomous: true

must_haves:
  truths:
    - "Partner's myStage cache updates immediately when Stage 2→3 transition fires"
    - "Partner's myStage cache updates immediately when advanceStage fires"
    - "Self-triggered stage transition events are filtered out (no double-update)"
  artifacts:
    - path: "mobile/src/screens/UnifiedSessionScreen.tsx"
      provides: "partner.stage_completed handler updates sessionKeys.state with new stage"
      contains: "sessionKeys.state"
    - path: "mobile/src/screens/UnifiedSessionScreen.tsx"
      provides: "partner.advanced handler updates sessionKeys.state with new stage"
      contains: "partner.advanced"
    - path: "backend/src/controllers/stage2.ts"
      provides: "triggerStage3Transition includes currentStage in event payload"
      contains: "currentStage: 3"
  key_links:
    - from: "backend/src/controllers/stage2.ts"
      to: "mobile/src/screens/UnifiedSessionScreen.tsx"
      via: "partner.stage_completed Ably event with currentStage field"
      pattern: "partner\\.stage_completed.*currentStage"
    - from: "backend/src/controllers/sessions.ts"
      to: "mobile/src/screens/UnifiedSessionScreen.tsx"
      via: "partner.advanced Ably event with toStage field"
      pattern: "partner\\.advanced.*toStage"
    - from: "mobile/src/screens/UnifiedSessionScreen.tsx"
      to: "sessionKeys.state"
      via: "setQueryData updating myProgress.stage"
      pattern: "sessionKeys\\.state.*myProgress.*stage"
---

<objective>
Fix partner cache updates so stage transitions update `sessionKeys.state` for the partner in real-time via Ably events.

Purpose: Currently, when one user triggers a stage transition (Stage 2→3 via validation, or any stage via advanceStage), the partner's `sessionKeys.state` cache is NOT updated. The partner's `myStage` remains stale until a background refetch (5-10 second delay). This causes incorrect panel visibility and stale UI. Fixing this satisfies TRANS-02 (partner receives Ably notification and cache/UI updates) and TRANS-04 (empathy sharing → reconciler → both users see correct post-reconciliation UI).

Output: Updated Ably event handlers on mobile and enriched event payloads from backend.
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-stage-transition-fixes/05-RESEARCH.md
@.planning/phases/01-audit/01-04-AUDIT-CACHE-UPDATES.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enrich backend event payloads with stage data and add partner.advanced handler on mobile</name>
  <files>
    backend/src/controllers/stage2.ts
    backend/src/controllers/sessions.ts
    mobile/src/screens/UnifiedSessionScreen.tsx
  </files>
  <action>
  **Backend changes:**

  1. In `backend/src/controllers/stage2.ts`, find `triggerStage3Transition` function (line ~1577). The `publishSessionEvent` call currently sends:
     ```typescript
     await publishSessionEvent(sessionId, 'partner.stage_completed', {
       previousStage: 2,
       currentStage: 3,
       userId,
       message: { id, content, timestamp }
     });
     ```
     Add `triggeredByUserId: userId` to the payload so the mobile handler can filter self-triggered events. The existing payload already includes `currentStage: 3` which is good.

  2. In `backend/src/controllers/sessions.ts`, find `advanceStage` function (line ~679). The `notifyPartner` call sends:
     ```typescript
     await notifyPartner(sessionId, partnerId, 'partner.advanced', {
       toStage: nextStage,
       advancedAt: now.toISOString(),
     });
     ```
     Add `triggeredByUserId: user.id` to the payload.

  **Mobile changes:**

  3. In `mobile/src/screens/UnifiedSessionScreen.tsx`, find the `onSessionEvent` callback. Locate the `partner.stage_completed` handler (line ~296). Currently it only does:
     ```typescript
     if (event === 'partner.stage_completed') {
       if (data.empathyStatus) {
         queryClient.setQueryData(stageKeys.empathyStatus(sessionId), data.empathyStatus);
       }
       queryClient.refetchQueries({ queryKey: stageKeys.progress(sessionId) });
     }
     ```
     Update to ALSO update `sessionKeys.state` cache with the new stage:
     ```typescript
     if (event === 'partner.stage_completed') {
       console.log('[UnifiedSessionScreen] Partner completed stage', data.currentStage);
       if (data.empathyStatus) {
         queryClient.setQueryData(stageKeys.empathyStatus(sessionId), data.empathyStatus);
       }
       // Update sessionKeys.state with new stage from event
       if (data.currentStage !== undefined) {
         queryClient.setQueryData(sessionKeys.state(sessionId), (old: any) => {
           if (!old) return old;
           return {
             ...old,
             progress: old.progress ? {
               ...old.progress,
               myProgress: old.progress.myProgress ? {
                 ...old.progress.myProgress,
                 stage: data.currentStage,
               } : old.progress.myProgress,
             } : old.progress,
           };
         });
       }
       // Also add transition message to cache if included in event
       if (data.message) {
         const newMessage = {
           id: data.message.id,
           content: data.message.content,
           timestamp: data.message.timestamp,
           stage: data.currentStage ?? 3,
           role: 'AI' as const,
           sessionId,
           senderId: null,
         };
         queryClient.setQueryData(messageKeys.infinite(sessionId), (old: any) => {
           if (!old || old.pages.length === 0) {
             return { pages: [{ messages: [newMessage], hasMore: false }], pageParams: [undefined] };
           }
           const firstPage = old.pages[0];
           const existingIds = new Set((firstPage.messages || []).map((m: any) => m.id));
           if (existingIds.has(newMessage.id)) return old;
           const updatedPages = [...old.pages];
           updatedPages[0] = { ...firstPage, messages: [...(firstPage.messages || []), newMessage] };
           return { ...old, pages: updatedPages };
         });
       }
       queryClient.refetchQueries({ queryKey: stageKeys.progress(sessionId) });
     }
     ```

  4. In the same `onSessionEvent` callback, add a NEW handler for `partner.advanced` events (currently completely missing). Add it near the `partner.stage_completed` handler:
     ```typescript
     if (event === 'partner.advanced') {
       console.log('[UnifiedSessionScreen] Partner advanced to stage', data.toStage);
       if (data.toStage !== undefined) {
         // Update partner's stage in sessionKeys.state
         queryClient.setQueryData(sessionKeys.state(sessionId), (old: any) => {
           if (!old) return old;
           return {
             ...old,
             progress: old.progress ? {
               ...old.progress,
               partnerProgress: old.progress.partnerProgress ? {
                 ...old.progress.partnerProgress,
                 stage: data.toStage,
               } : old.progress.partnerProgress,
             } : old.progress,
           };
         });
       }
       queryClient.refetchQueries({ queryKey: stageKeys.progress(sessionId) });
     }
     ```
     NOTE: `partner.advanced` updates `partnerProgress.stage` (not `myProgress.stage`) because this is about the PARTNER advancing, and the event is received by the OTHER user.

  5. Make sure `sessionKeys` and `messageKeys` are imported in UnifiedSessionScreen.tsx. Check existing imports -- they should already be available from `queryKeys.ts`.

  **Critical distinction:**
  - `partner.stage_completed` from `triggerStage3Transition` updates `myProgress.stage` because it advances BOTH users to Stage 3
  - `partner.advanced` from `advanceStage` updates `partnerProgress.stage` because only the partner advanced
  </action>
  <verify>
  Run type checking:
  ```bash
  cd /Users/shantam/Software/meet-without-fear && npm run check
  ```
  Run backend tests:
  ```bash
  cd /Users/shantam/Software/meet-without-fear && npm run test --workspace=backend
  ```
  Verify the event handler exists:
  ```bash
  grep -n "partner.advanced" mobile/src/screens/UnifiedSessionScreen.tsx
  grep -n "partner.stage_completed" mobile/src/screens/UnifiedSessionScreen.tsx | grep "sessionKeys.state"
  grep -n "triggeredByUserId" backend/src/controllers/stage2.ts | grep "triggerStage3"
  ```
  </verify>
  <done>
  1. `partner.stage_completed` handler in UnifiedSessionScreen.tsx updates `sessionKeys.state` with `myProgress.stage` from `data.currentStage`
  2. `partner.stage_completed` handler adds transition message to infinite message cache when included in event payload
  3. New `partner.advanced` handler in UnifiedSessionScreen.tsx updates `sessionKeys.state` with `partnerProgress.stage` from `data.toStage`
  4. `triggerStage3Transition` includes `triggeredByUserId` in event payload
  5. `advanceStage` includes `triggeredByUserId` in event payload
  6. Type checking passes, backend tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Stage 0 Ably events for compact signing and invitation confirmation</name>
  <files>
    backend/src/controllers/stage0.ts
    backend/src/controllers/sessions.ts
    mobile/src/screens/UnifiedSessionScreen.tsx
  </files>
  <action>
  Stage 0 currently has NO session-specific Ably events for compact signing or invitation confirmation. Partner relies on user-level refetch polling (5-10s latency). Add real-time events to reduce latency.

  **Backend changes:**

  1. In `backend/src/controllers/stage0.ts`, find the compact signing endpoint handler. After the DB write that records the compact signature, add:
     ```typescript
     // Notify partner that user signed compact
     if (partnerId) {
       await publishSessionEvent(sessionId, 'partner.signed_compact', {
         signedBy: user.id,
         triggeredByUserId: user.id,
         timestamp: new Date().toISOString(),
       });
     }
     ```
     Import `publishSessionEvent` from `'../services/realtime'` if not already imported.
     Locate the partner ID by checking session members (follow existing pattern in the same file).

  2. In `backend/src/controllers/sessions.ts`, find the `confirmInvitationMessage` handler (the function that handles `useConfirmInvitationMessage` on mobile). After the invitation is confirmed and response sent, add:
     ```typescript
     // Notify session that invitation was confirmed
     await publishSessionEvent(sessionId, 'invitation.confirmed', {
       confirmedBy: user.id,
       triggeredByUserId: user.id,
       timestamp: new Date().toISOString(),
     });
     ```
     NOTE: This event may not have a recipient yet (invitee may not exist), so use `publishSessionEvent` on the session channel. It's a no-op if nobody is listening.

  **Mobile changes:**

  3. In `mobile/src/screens/UnifiedSessionScreen.tsx`, add handlers in the `onSessionEvent` callback:
     ```typescript
     if (event === 'partner.signed_compact') {
       console.log('[UnifiedSessionScreen] Partner signed compact');
       // Refetch session state to update compact status UI
       queryClient.invalidateQueries({ queryKey: sessionKeys.state(sessionId) });
     }

     if (event === 'invitation.confirmed') {
       console.log('[UnifiedSessionScreen] Invitation confirmed');
       // Refetch session state and invitation data
       queryClient.invalidateQueries({ queryKey: sessionKeys.state(sessionId) });
       queryClient.invalidateQueries({ queryKey: sessionKeys.sessionInvitation(sessionId) });
     }
     ```
     For Stage 0 events, `invalidateQueries` is appropriate (not `setQueryData`) because:
     - There's no urgency for instant update (user isn't actively waiting for frame-precise feedback)
     - The invalidation triggers an immediate background refetch which resolves in <500ms
     - The server response contains the complete state, so we get the full truth without manual assembly

  4. Verify the `partner.signed_compact` event type is already in the `SessionEvent` union type in `backend/src/services/realtime.ts`. If not, add it. The `invitation.confirmed` event type also needs to be added if missing.
  </action>
  <verify>
  Run type checking:
  ```bash
  cd /Users/shantam/Software/meet-without-fear && npm run check
  ```
  Run backend tests:
  ```bash
  cd /Users/shantam/Software/meet-without-fear && npm run test --workspace=backend
  ```
  Verify events are published:
  ```bash
  grep -n "partner.signed_compact" backend/src/controllers/stage0.ts
  grep -n "invitation.confirmed" backend/src/controllers/sessions.ts
  grep -n "partner.signed_compact" mobile/src/screens/UnifiedSessionScreen.tsx
  grep -n "invitation.confirmed" mobile/src/screens/UnifiedSessionScreen.tsx
  ```
  </verify>
  <done>
  1. Backend publishes `partner.signed_compact` event when user signs compact
  2. Backend publishes `invitation.confirmed` event when inviter confirms invitation message
  3. Mobile handles `partner.signed_compact` by invalidating `sessionKeys.state` for immediate refetch
  4. Mobile handles `invitation.confirmed` by invalidating session state and invitation caches
  5. Event types are registered in `SessionEvent` union type
  6. Type checking passes, backend tests pass
  </done>
</task>

</tasks>

<verification>
1. Type checking passes: `npm run check`
2. Backend tests pass: `npm run test --workspace=backend`
3. Mobile type checking passes (covered by `npm run check`)
4. grep confirms all new event handlers exist in UnifiedSessionScreen.tsx
5. grep confirms all new event publications exist in backend controllers
6. Existing E2E tests (Stage 0-1, Stage 2) still pass: `cd e2e && npx playwright test --config=playwright.two-browser.config.ts`
</verification>

<success_criteria>
- partner.stage_completed handler updates sessionKeys.state.progress.myProgress.stage
- partner.advanced handler updates sessionKeys.state.progress.partnerProgress.stage
- partner.signed_compact event published from backend and handled on mobile
- invitation.confirmed event published from backend and handled on mobile
- npm run check passes (zero type errors)
- npm run test --workspace=backend passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-stage-transition-fixes/05-01-SUMMARY.md`
</output>
