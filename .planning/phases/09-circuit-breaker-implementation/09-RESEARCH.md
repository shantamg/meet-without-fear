# Phase 9: Circuit Breaker Implementation - Research

**Researched:** 2026-02-17
**Domain:** Backend safety mechanism - refinement attempt counter with database persistence
**Confidence:** HIGH

## Summary

Phase 9 implements a circuit breaker that prevents infinite empathy refinement loops by tracking and limiting attempts per direction. When a guesser's empathy is repeatedly flagged by the reconciler (AWAITING_SHARING, REFINING), the circuit breaker forces progression after 3 attempts by skipping reconciler evaluation and marking the empathy as READY.

The circuit breaker is a pure backend safety mechanism: it adds a counter table, checks/increments atomically before reconciler calls, and forces READY status on the 4th attempt. No UI changes, no new user flows — just a guard preventing stuck sessions.

**Primary recommendation:** Add a `RefinementAttemptCounter` Prisma model with composite unique key `(sessionId, direction)`, implement atomic check-and-increment logic in `runReconcilerForDirection`, and verify with a single E2E test that forces 4 attempts and screenshots the graceful progression message.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
None — user gave full discretion on all implementation choices.

### Claude's Discretion

**All implementation choices are Claude's discretion.** The following are recommended defaults based on the user context:

**Trigger threshold:**
- 3 refinement attempts per direction (A→B tracked separately from B→A)
- An "attempt" = each time the reconciler evaluates a guesser's empathy and returns a non-READY result (AWAITING_SHARING, REFINING, etc.)
- The sharer's initial sharing does not count as an attempt

**Breaking behavior:**
- On the 4th attempt, skip reconciler evaluation entirely and force READY status
- Both users progress as if empathy was accepted
- No partial states — once tripped, that direction is done

**User communication:**
- Brief, non-alarming AI message to both users acknowledging the cap (e.g., "We've captured your perspective — let's move forward")
- No warning before the last attempt — just graceful progression when the limit hits
- The message should feel like a natural transition, not an error

**Counting & persistence:**
- Counter stored in database (not in-memory) so it survives server restarts
- Per session, per direction (sessionId + direction as composite key)
- No reset within a session — once attempts are used, they're used

**Edge cases:**
- Each direction is fully independent — A→B can trip while B→A has attempts remaining
- If both directions trip simultaneously, both get READY status independently
- Concurrent refinements: each reconciler call checks/increments atomically (DB-level)

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope

</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| RECON-EC-04 | Circuit breaker limits refinement to 3 attempts per direction, then forces READY status | Database counter model (PostgreSQL + Prisma), atomic transaction pattern, reconciler integration point identified |

</phase_requirements>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Prisma | 6.19.1 | Database ORM + migrations | Project standard for all DB operations, type-safe client |
| PostgreSQL | (via Prisma) | Relational database | Project standard, supports transactions, unique constraints |
| TypeScript | Project | Type safety | All backend code is TypeScript |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Prisma Transactions | Built-in | Atomic operations | Use `prisma.$transaction()` for check-then-increment logic (alternative: rely on unique constraint) |
| Playwright | Latest (project) | E2E testing | Verify 4th attempt behavior with two-browser test |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Database counter | In-memory Map | DB survives restarts, handles multi-instance deployments (future) |
| Prisma model | Separate counter service | Prisma is simpler, follows project patterns, migrations tracked |
| Transaction for increment | Unique constraint + catch | Transaction is more explicit, easier to understand intent |

**Installation:**
```bash
# No new dependencies - uses existing Prisma setup
cd backend && npx prisma migrate dev --name add_refinement_counter
```

## Architecture Patterns

### Recommended Project Structure
```
backend/
├── prisma/
│   ├── schema.prisma                  # Add RefinementAttemptCounter model
│   └── migrations/
│       └── {timestamp}_add_refinement_counter/
│           └── migration.sql          # Auto-generated by Prisma
├── src/
│   ├── services/
│   │   └── reconciler.ts              # Modify runReconcilerForDirection
│   └── utils/
│       └── circuit-breaker.ts         # Existing file (timeout utils, not relevant)
e2e/tests/
└── two-browser-circuit-breaker.spec.ts  # New E2E test
```

### Pattern 1: Database Counter Model (Prisma)
**What:** Create a Prisma model to track refinement attempts per session-direction
**When to use:** When you need persistent, queryable counters with composite keys
**Example:**
```prisma
// Source: Recommended pattern based on existing models in schema.prisma

model RefinementAttemptCounter {
  id        String   @id @default(cuid())
  sessionId String
  // Direction: "guesserId->subjectId" (e.g., "user123->user456")
  // Stores the direction as a composite string to simplify queries
  direction String
  attempts  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, direction])
  @@index([sessionId])
}
```

**Why this pattern:**
- Follows existing Prisma model conventions in project (cuid ID, timestamps)
- `@@unique([sessionId, direction])` prevents duplicate counters for same direction
- Index on `sessionId` supports efficient lookups during reconciler runs
- `direction` as string (e.g., "userA->userB") is simpler than separate guesserId/subjectId fields

### Pattern 2: Atomic Check-and-Increment
**What:** Query current attempts, check if >= 3, increment if < 3, all in one DB round-trip
**When to use:** When you need to prevent race conditions between concurrent reconciler calls
**Example:**
```typescript
// Source: Adapted from existing Prisma transaction patterns in project

async function checkAndIncrementAttempts(
  sessionId: string,
  guesserId: string,
  subjectId: string
): Promise<{ shouldSkipReconciler: boolean; attempts: number }> {
  const direction = `${guesserId}->${subjectId}`;

  // Upsert: create if doesn't exist, increment if exists
  const counter = await prisma.refinementAttemptCounter.upsert({
    where: {
      sessionId_direction: { sessionId, direction },
    },
    create: {
      sessionId,
      direction,
      attempts: 1,
    },
    update: {
      attempts: { increment: 1 },
    },
  });

  // Check if we've hit the limit (attempts is AFTER increment)
  const shouldSkipReconciler = counter.attempts > 3;

  console.log(
    `[CircuitBreaker] Direction ${direction}: attempt ${counter.attempts}/3, ` +
    `shouldSkip=${shouldSkipReconciler}`
  );

  return { shouldSkipReconciler, attempts: counter.attempts };
}
```

**Why this pattern:**
- Single `upsert` is atomic at DB level (PostgreSQL guarantees)
- No need for explicit transaction wrapper
- `attempts: { increment: 1 }` is Prisma's atomic increment syntax
- Returns incremented value so caller can check threshold

**Alternative (more defensive):**
```typescript
// If concurrency is a concern, wrap in transaction
await prisma.$transaction(async (tx) => {
  const counter = await tx.refinementAttemptCounter.upsert({ ... });
  return { shouldSkipReconciler: counter.attempts > 3, attempts: counter.attempts };
});
```

### Pattern 3: Integration with Reconciler
**What:** Call circuit breaker check at the START of `runReconcilerForDirection`, before any reconciler logic
**When to use:** When you want to short-circuit expensive operations (AI calls, DB queries)
**Example:**
```typescript
// Source: Adapted from reconciler.ts runReconcilerForDirection (lines 672-838)

export async function runReconcilerForDirection(
  sessionId: string,
  guesserId: string,
  subjectId: string
): Promise<{ result: ReconcilerResult | null; empathyStatus: 'READY' | 'AWAITING_SHARING'; ... }> {
  console.log(`[Reconciler] Running asymmetric reconciliation: ${guesserId} (guesser) → ${subjectId} (subject)`);

  // ============================================================================
  // CIRCUIT BREAKER CHECK
  // ============================================================================
  const { shouldSkipReconciler, attempts } = await checkAndIncrementAttempts(
    sessionId,
    guesserId,
    subjectId
  );

  if (shouldSkipReconciler) {
    console.log(`[Reconciler] Circuit breaker tripped (${attempts} attempts). Forcing READY.`);

    // Get subject name for message
    const subject = await prisma.user.findUnique({
      where: { id: subjectId },
      select: { firstName: true, name: true },
    });
    const subjectName = subject?.firstName || subject?.name || 'your partner';

    // Force READY (reuses existing helper)
    await markEmpathyReady(sessionId, guesserId, subjectName);

    return {
      result: null, // No reconciler result generated
      empathyStatus: 'READY',
      shareOffer: null,
    };
  }

  // ============================================================================
  // NORMAL RECONCILER FLOW (existing code continues here)
  // ============================================================================
  // ... existing reconciler logic ...
}
```

**Why this pattern:**
- Check happens BEFORE expensive operations (AI calls, reconciler analysis)
- Reuses existing `markEmpathyReady` helper (lines 143-190 in reconciler.ts)
- Returns same shape as normal path (null result + READY status)
- Logging makes circuit breaker trips visible in logs/dashboard

### Pattern 4: Circuit Breaker Message Generation
**What:** Generate a brief, non-alarming transition message when circuit breaker trips
**When to use:** When forcing READY status due to circuit breaker
**Example:**
```typescript
// Source: Adapted from markEmpathyReady helper in reconciler.ts (lines 143-190)

async function markEmpathyReady(
  sessionId: string,
  guesserId: string,
  subjectName: string,
  circuitBreakerTripped = false
): Promise<void> {
  console.log(`[Reconciler] Marking empathy as READY for guesser ${guesserId}`);

  // Update empathy attempt status to READY
  await prisma.empathyAttempt.updateMany({
    where: { sessionId, sourceUserId: guesserId },
    data: { status: 'READY' },
  });

  // Choose message based on whether circuit breaker tripped
  const message = circuitBreakerTripped
    ? `You've shared your perspective on what ${subjectName} might be experiencing. Let's move forward — ${subjectName} is also reflecting on your perspective.`
    : `${subjectName} has felt heard. The reconciler reports your attempt to imagine what they're feeling was quite accurate. ${subjectName} is now considering your perspective, and once they do, you'll both see what each other shared.`;

  const savedMessage = await prisma.message.create({
    data: {
      sessionId,
      senderId: null, // AI message
      forUserId: guesserId,
      role: 'AI',
      content: message,
      stage: 2,
    },
  });

  // Publish via Ably
  await publishMessageAIResponse(sessionId, guesserId, { ... }, {});

  // Check if both directions are now READY and reveal both if so
  await checkAndRevealBothIfReady(sessionId);
}
```

**Why this pattern:**
- Message tone is positive, not error-like ("Let's move forward" vs "Limit reached")
- Both users get a message (guesser gets explicit message, subject gets normal flow)
- Reuses existing `checkAndRevealBothIfReady` logic (lines 2246-2304 in reconciler.ts)
- Optional parameter keeps function signature backward-compatible

### Anti-Patterns to Avoid
- **DON'T store attempts in memory** - Server restarts lose state, multi-instance deploys won't work
- **DON'T increment counter AFTER reconciler runs** - Wastes AI calls/compute on 4th attempt
- **DON'T use separate guesserId/subjectId columns** - Composite string is simpler, follows "direction" concept
- **DON'T reset counter mid-session** - Circuit breaker is permanent per session
- **DON'T show error UI** - Users should feel progression is natural, not blocked

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Atomic counter increment | SELECT + UPDATE in separate queries | Prisma `upsert` with `increment` | PostgreSQL guarantees atomicity, prevents race conditions |
| Counter persistence | Redis/in-memory cache | PostgreSQL via Prisma | Already in stack, migrations tracked, survives restarts |
| Direction encoding | Separate guesserId/subjectId columns | Composite string "userA->userB" | Simpler queries, matches conceptual "direction" |
| Transaction wrapping | Manual BEGIN/COMMIT | Prisma `$transaction()` or atomic `upsert` | Prisma handles connection pooling, retry logic |

**Key insight:** Prisma's `upsert` with atomic increment is the sweet spot for this use case. Transactions add complexity without benefit since `upsert` is already atomic.

## Common Pitfalls

### Pitfall 1: Incrementing Counter After Reconciler Call
**What goes wrong:** You call reconciler, THEN increment counter if it returned non-READY
**Why it happens:** Seems logical to only count "failed" attempts
**How to avoid:** Increment BEFORE reconciler call. An "attempt" is each reconciler evaluation, not each failure.
**Warning signs:** 4th attempt still runs full reconciler analysis, wastes AI tokens

**Correct flow:**
1. Increment counter
2. Check if counter > 3
3. If yes, skip reconciler and force READY
4. If no, run reconciler normally

### Pitfall 2: Using Separate guesserId/subjectId Columns
**What goes wrong:** Schema has `guesserId` and `subjectId` columns, requires two lookups per direction
**Why it happens:** Mirrors ReconcilerResult schema pattern
**How to avoid:** Use composite string direction "guesserId->subjectId" as single column
**Warning signs:** Complex WHERE clauses, need to query both (A,B) and (B,A) separately

**Correct schema:**
```prisma
@@unique([sessionId, direction])  // direction = "userA->userB"
```

Not:
```prisma
@@unique([sessionId, guesserId, subjectId])  // Requires knowing order
```

### Pitfall 3: Showing Error UI When Circuit Breaker Trips
**What goes wrong:** UI shows "Maximum attempts reached" error panel
**Why it happens:** Treating circuit breaker like a validation failure
**How to avoid:** Circuit breaker should be invisible to users — they just see natural progression
**Warning signs:** User feels blocked, creates support tickets

**Correct UX:** Both users see empathy revealed, validation flow continues normally. The only hint is slightly different AI message wording ("Let's move forward" vs "quite accurate").

### Pitfall 4: Not Handling Both Directions Independently
**What goes wrong:** Circuit breaker counts total attempts across both directions, A→B and B→A share counter
**Why it happens:** Thinking of it as "session refinement limit" not "per-direction limit"
**How to avoid:** Each direction gets its own counter (separate DB rows)
**Warning signs:** User A trips circuit breaker for B, but B's refinement of A is also blocked

**Correct tracking:**
- Session S, direction "A->B": 3 attempts
- Session S, direction "B->A": 1 attempt
- A→B circuit breaks, B→A continues normally

## Code Examples

Verified patterns from official sources and project conventions:

### Creating Prisma Migration
```bash
# Source: Project pattern (see CLAUDE.md Database Migrations section)
cd backend
npx prisma migrate dev --name add_refinement_attempt_counter

# Migration creates:
# prisma/migrations/{timestamp}_add_refinement_attempt_counter/migration.sql
```

### Querying Counter Before Reconciler
```typescript
// Source: Adapted from existing reconciler.ts patterns

// At top of runReconcilerForDirection (before existing logic)
const direction = `${guesserId}->${subjectId}`;

const counter = await prisma.refinementAttemptCounter.upsert({
  where: { sessionId_direction: { sessionId, direction } },
  create: { sessionId, direction, attempts: 1 },
  update: { attempts: { increment: 1 } },
});

if (counter.attempts > 3) {
  // Circuit breaker tripped - force READY and return early
  console.log(`[CircuitBreaker] Attempt ${counter.attempts} for ${direction} - forcing READY`);
  await markEmpathyReady(sessionId, guesserId, subjectName, true);
  return { result: null, empathyStatus: 'READY', shareOffer: null };
}
```

### E2E Test Pattern (Two-Browser with Fixture)
```typescript
// Source: Adapted from two-browser-reconciler-offer-sharing-refinement.spec.ts

test('circuit breaker forces READY after 3 refinement attempts', async () => {
  test.setTimeout(900000); // 15 min - requires multiple refinement loops

  // Create fixture that returns OFFER_SHARING for first 3 attempts
  // On 4th call, reconciler should be skipped (never called)
  const refinementFixture: E2EFixture = {
    name: 'Circuit Breaker Test',
    operations: {
      'reconciler-analysis': {
        // First 3 calls return OFFER_SHARING
        response: { /* OFFER_SHARING result */ },
        callCount: 3, // After 3rd call, fixture throws if called again
      },
    },
  };

  // Setup harness with fixture
  harness = new TwoBrowserHarness({
    userA: { email: 'cb-a@e2e.test', name: 'Alice', fixtureId: 'user-a-full-journey' },
    userB: { email: 'cb-b@e2e.test', name: 'Bob', fixtureId: 'circuit-breaker-test' },
  });

  // Both users complete Stage 0+1
  // User A shares empathy (guesser)
  // User B shares empathy (subject, triggers reconciler)

  // Loop 1: Reconciler returns OFFER_SHARING → subject shares → guesser refines
  // Loop 2: Reconciler returns OFFER_SHARING → subject shares → guesser refines
  // Loop 3: Reconciler returns OFFER_SHARING → subject shares → guesser refines
  // Loop 4: Circuit breaker trips → both see READY, empathy revealed

  // Verify final state
  await expect(harness.userAPage.getByTestId('empathy-statement-partner')).toBeVisible();
  await expect(harness.userBPage.getByTestId('empathy-statement-partner')).toBeVisible();

  // Screenshot circuit breaker message
  await harness.userAPage.screenshot({ path: 'test-results/circuit-breaker-message.png' });
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| No refinement limit | Circuit breaker after 3 attempts | Phase 9 (v1.1) | Prevents infinite loops, improves UX for edge cases |
| In-memory counters (theoretical) | Database persistence | From start (recommended) | Survives restarts, multi-instance ready |
| Global refinement limit | Per-direction counters | From start (user decision) | A→B and B→A independent |

**Deprecated/outdated:**
- N/A - This is net new functionality

**Current best practice:**
- Database-persisted counters with atomic increment (Prisma upsert)
- Check BEFORE expensive operations (reconciler AI calls)
- Graceful UX (natural progression, not error state)

## Open Questions

1. **Should we add a "attempts remaining" indicator to the UI?**
   - What we know: User preference is for invisible circuit breaker (no warning)
   - What's unclear: Whether seeing "2 attempts remaining" would help or harm UX
   - Recommendation: Start without indicator (per user preference), gather feedback

2. **Should circuit breaker counter be visible in admin/debug tools?**
   - What we know: Counter is in DB, queryable
   - What's unclear: Whether dashboard should surface this metric
   - Recommendation: Add to BrainActivity logging for visibility, defer dashboard UI

3. **What happens if circuit breaker trips for both directions simultaneously?**
   - What we know: Each direction is independent
   - What's unclear: Whether we need special handling if both trip on same reconciler run
   - Recommendation: Current implementation handles it correctly (both marked READY independently)

## Sources

### Primary (HIGH confidence)
- `/Users/shantam/Software/meet-without-fear/backend/prisma/schema.prisma` - Existing Prisma model patterns (RefinementAttemptCounter follows ReconcilerResult conventions)
- `/Users/shantam/Software/meet-without-fear/backend/src/services/reconciler.ts` - Integration point (runReconcilerForDirection lines 672-838), markEmpathyReady helper (lines 143-190)
- `/Users/shantam/Software/meet-without-fear/.planning/phases/08-reconciler-documentation-edge-cases/08-RESEARCH.md` - E2E test patterns, fixture structure, two-browser harness usage
- Prisma documentation (via knowledge) - `upsert` atomic increment syntax
- Project CLAUDE.md - Database migration practices, never use `db push`

### Secondary (MEDIUM confidence)
- Phase 8 execution summaries (08-04-SUMMARY.md) - Refinement flow context, hasContextAlreadyBeenShared guard pattern
- `.planning/REQUIREMENTS.md` - RECON-EC-04 requirement definition (lines 20, 94)

### Tertiary (LOW confidence)
- N/A - All findings verified against codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Prisma 6.19.1 confirmed, PostgreSQL in use, migration pattern documented
- Architecture: HIGH - Integration point identified in reconciler.ts, existing helpers reusable
- Pitfalls: MEDIUM-HIGH - Based on general circuit breaker patterns and project conventions, not battle-tested in this exact context

**Research date:** 2026-02-17
**Valid until:** 90 days (stable technology - Prisma, PostgreSQL)

**Key findings:**
1. Circuit breaker is pure backend - no UI changes required
2. Integration point is clear: runReconcilerForDirection line ~690 (before existing logic)
3. Atomic increment via Prisma upsert is sufficient, no transaction wrapper needed
4. Existing markEmpathyReady helper can be reused with optional circuitBreakerTripped parameter
5. E2E test follows Phase 8 two-browser pattern with fixture-controlled attempts
