---
phase: 09-circuit-breaker-implementation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/prisma/schema.prisma
  - backend/src/services/reconciler.ts
  - backend/src/__tests__/circuit-breaker.test.ts
autonomous: true
requirements:
  - RECON-EC-04

must_haves:
  truths:
    - "RefinementAttemptCounter model exists in Prisma schema with composite unique key (sessionId, direction)"
    - "Reconciler increments attempt counter before evaluating empathy and skips evaluation on 4th+ attempt"
    - "When circuit breaker trips, empathy is force-marked READY with a natural transition message"
    - "Each direction (A->B, B->A) is tracked independently"
  artifacts:
    - path: "backend/prisma/schema.prisma"
      provides: "RefinementAttemptCounter model"
      contains: "model RefinementAttemptCounter"
    - path: "backend/src/services/reconciler.ts"
      provides: "Circuit breaker check in runReconcilerForDirection + circuitBreakerTripped parameter in markEmpathyReady"
    - path: "backend/src/__tests__/circuit-breaker.test.ts"
      provides: "Unit tests for circuit breaker increment logic"
  key_links:
    - from: "backend/src/services/reconciler.ts"
      to: "prisma.refinementAttemptCounter"
      via: "upsert with atomic increment at start of runReconcilerForDirection"
      pattern: "prisma\\.refinementAttemptCounter\\.upsert"
    - from: "backend/src/services/reconciler.ts"
      to: "markEmpathyReady"
      via: "called with circuitBreakerTripped=true when counter > 3"
      pattern: "markEmpathyReady.*circuitBreakerTripped"
---

<objective>
Implement the circuit breaker database model and integrate it into the reconciler so that empathy refinement loops are bounded at 3 attempts per direction.

Purpose: Prevents infinite back-and-forth when reconciler repeatedly flags empathy as inaccurate. After 3 attempts, the system gracefully forces progression instead of looping forever.

Output: Prisma migration with RefinementAttemptCounter model, atomic check-and-increment logic in runReconcilerForDirection, and unit tests proving the threshold behavior.
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-circuit-breaker-implementation/09-RESEARCH.md
@backend/prisma/schema.prisma
@backend/src/services/reconciler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Add RefinementAttemptCounter model and write failing circuit breaker tests</name>
  <files>
    backend/prisma/schema.prisma
    backend/src/__tests__/circuit-breaker.test.ts
  </files>
  <action>
**Prisma Model:**

Add `RefinementAttemptCounter` model to `schema.prisma` (after the `ReconcilerShareOffer` model):

```prisma
model RefinementAttemptCounter {
  id        String   @id @default(cuid())
  sessionId String
  direction String   // "guesserId->subjectId" composite string
  attempts  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, direction])
  @@index([sessionId])
}
```

Run migration: `cd backend && npx prisma migrate dev --name add_refinement_attempt_counter`

**Tests (RED):**

Create `backend/src/__tests__/circuit-breaker.test.ts` with tests that exercise a `checkAndIncrementAttempts` function (which doesn't exist yet):

1. **"first attempt returns shouldSkip=false with attempts=1"** — Call once, verify shouldSkip is false and attempts is 1.
2. **"third attempt returns shouldSkip=false with attempts=3"** — Call 3 times, verify third call has shouldSkip=false and attempts=3.
3. **"fourth attempt returns shouldSkip=true"** — Call 4 times, verify fourth call has shouldSkip=true and attempts=4.
4. **"tracks directions independently"** — Call 3 times for direction A->B, then call once for B->A. Verify B->A has attempts=1 and shouldSkip=false.
5. **"persists across function calls"** — Call twice, verify second call has attempts=2 (not 1).

Import the function from `../services/reconciler` (it won't exist yet, so tests should fail). Use real Prisma client against test database. Setup/teardown should clean up RefinementAttemptCounter rows for the test sessionId.

Run tests: `cd backend && npm test -- --testPathPattern=circuit-breaker --verbose` — expect failures (function doesn't exist).
  </action>
  <verify>
- `npx prisma migrate dev --name add_refinement_attempt_counter` completes successfully
- `npm run check` passes (Prisma types regenerated)
- `cd backend && npm test -- --testPathPattern=circuit-breaker --verbose` — tests fail because `checkAndIncrementAttempts` doesn't exist yet
  </verify>
  <done>
- RefinementAttemptCounter model exists in schema.prisma with @@unique([sessionId, direction]) and @@index([sessionId])
- Migration file generated and applied
- 5 test cases written and failing (RED state)
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement checkAndIncrementAttempts and integrate into reconciler</name>
  <files>
    backend/src/services/reconciler.ts
  </files>
  <action>
**Step 1: Create checkAndIncrementAttempts function**

Add an exported async function `checkAndIncrementAttempts` to `reconciler.ts` (near top, after imports/helpers):

```typescript
export async function checkAndIncrementAttempts(
  sessionId: string,
  guesserId: string,
  subjectId: string
): Promise<{ shouldSkipReconciler: boolean; attempts: number }> {
  const direction = `${guesserId}->${subjectId}`;

  const counter = await prisma.refinementAttemptCounter.upsert({
    where: { sessionId_direction: { sessionId, direction } },
    create: { sessionId, direction, attempts: 1 },
    update: { attempts: { increment: 1 } },
  });

  const shouldSkipReconciler = counter.attempts > 3;

  console.log(
    `[CircuitBreaker] Direction ${direction}: attempt ${counter.attempts}/3, shouldSkip=${shouldSkipReconciler}`
  );

  return { shouldSkipReconciler, attempts: counter.attempts };
}
```

Key details:
- Uses Prisma `upsert` which is atomic at the PostgreSQL level
- `create` sets attempts to 1 (first attempt), `update` atomically increments
- Threshold check is `> 3` (so attempts 1-3 are allowed, 4+ triggers skip)
- Direction string is `guesserId->subjectId` composite

**Step 2: Modify markEmpathyReady to accept circuitBreakerTripped parameter**

Update the function signature to:
```typescript
async function markEmpathyReady(
  sessionId: string,
  guesserId: string,
  subjectName: string,
  circuitBreakerTripped = false
): Promise<void>
```

Change the alignment message logic:
```typescript
const alignmentMessage = circuitBreakerTripped
  ? `You've shared your perspective on what ${subjectName} might be experiencing. Let's move forward — ${subjectName} is also reflecting on your perspective.`
  : `${subjectName} has felt heard. The reconciler reports your attempt to imagine what they're feeling was quite accurate. ${subjectName} is now considering your perspective, and once they do, you'll both see what each other shared.`;
```

Existing callers pass no fourth argument, so they'll get `false` (backward-compatible).

**Step 3: Integrate circuit breaker into runReconcilerForDirection**

At the START of `runReconcilerForDirection` (after the guesser/subject lookup, before any reconciler AI calls), add:

```typescript
// ============================================================================
// CIRCUIT BREAKER CHECK
// ============================================================================
const { shouldSkipReconciler, attempts } = await checkAndIncrementAttempts(
  sessionId,
  guesserId,
  subjectId
);

if (shouldSkipReconciler) {
  console.log(`[Reconciler] Circuit breaker tripped (${attempts} attempts). Forcing READY for ${guesserInfo.name} → ${subjectInfo.name}.`);
  await markEmpathyReady(sessionId, guesserId, subjectInfo.name, true);
  return {
    result: null,
    empathyStatus: 'READY',
    shareOffer: null,
  };
}
```

Place this after the user lookups (which set `guesser` and `subject` vars) and the `guesserInfo`/`subjectInfo` construction, but BEFORE the existing reconciler logic (the getWitnessingContent, getEmpathyContent, etc. calls). This ensures no AI tokens are spent when circuit breaker trips.

Run tests: `cd backend && npm test -- --testPathPattern=circuit-breaker --verbose` — all 5 should pass.
  </action>
  <verify>
- `cd backend && npm test -- --testPathPattern=circuit-breaker --verbose` — all 5 tests pass (GREEN)
- `npm run check` — type checking passes across all workspaces
- `cd backend && npm test` — all existing backend tests still pass (no regressions)
  </verify>
  <done>
- checkAndIncrementAttempts function exported from reconciler.ts
- markEmpathyReady accepts optional circuitBreakerTripped parameter with natural transition message
- runReconcilerForDirection checks circuit breaker before any AI calls
- All 5 circuit breaker tests pass
- All existing backend tests pass (no regressions)
  </done>
</task>

</tasks>

<verification>
```bash
# Prisma migration applied
cd backend && npx prisma migrate status

# Type checking
npm run check

# Circuit breaker tests
cd backend && npm test -- --testPathPattern=circuit-breaker --verbose

# All backend tests (regression)
cd backend && npm test

# Verify schema has new model
grep -A 10 "model RefinementAttemptCounter" backend/prisma/schema.prisma
```
</verification>

<success_criteria>
1. RefinementAttemptCounter Prisma model with composite unique key exists and migration applied
2. checkAndIncrementAttempts atomically increments via Prisma upsert
3. 4th attempt returns shouldSkipReconciler=true
4. runReconcilerForDirection calls circuit breaker before AI calls
5. When circuit breaker trips, markEmpathyReady called with circuitBreakerTripped=true
6. Transition message is natural ("Let's move forward") not error-like
7. All tests pass (5 new + existing)
</success_criteria>

<output>
After completion, create `.planning/phases/09-circuit-breaker-implementation/09-01-SUMMARY.md`
</output>
