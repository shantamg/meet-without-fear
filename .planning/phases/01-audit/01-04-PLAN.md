---
phase: 01-audit
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - .planning/phases/01-audit/01-04-AUDIT-CACHE-UPDATES.md
autonomous: true

must_haves:
  truths:
    - "Every location where manual cache updates occur in mobile hooks is identified with exact file and function"
    - "Each cache update is verified against the expected cache key (from queryKeys.ts) for correctness"
    - "Missing or incorrect cache updates are flagged with specific remediation notes"
    - "Ably event handlers that update or invalidate cache are mapped to their source events"
  artifacts:
    - path: ".planning/phases/01-audit/01-04-AUDIT-CACHE-UPDATES.md"
      provides: "Complete inventory of all manual cache update locations with correctness verification"
  key_links: []
---

<objective>
Identify every location where manual cache updates are performed in mobile hooks for Stages 0-2, verify each update writes to the correct cache key, and flag any missing or incorrect updates.

Purpose: The Cache-First architecture requires every mutation to manually update React Query cache via `onMutate`. A single mismatched cache key means writes go to a key nobody reads from, causing silent failures. This audit creates a complete inventory to catch these issues.

Output: `.planning/phases/01-audit/01-04-AUDIT-CACHE-UPDATES.md`
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior audit results (for cross-reference):
@.planning/phases/01-audit/01-01-SUMMARY.md
@.planning/phases/01-audit/01-02-SUMMARY.md
@.planning/phases/01-audit/01-03-SUMMARY.md

Mobile cache infrastructure:
@mobile/src/hooks/queryKeys.ts
@mobile/src/hooks/useSessions.ts
@mobile/src/hooks/useStages.ts
@mobile/src/hooks/useMessages.ts
@mobile/src/hooks/useRealtime.ts
@mobile/src/hooks/useStreamingMessage.ts
@mobile/src/hooks/useChatUIState.ts
@mobile/src/hooks/useUnifiedSession.ts
@mobile/src/utils/chatUIState.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inventory all manual cache update locations in mutation hooks</name>
  <files>.planning/phases/01-audit/01-04-AUDIT-CACHE-UPDATES.md</files>
  <action>
Read every mutation hook in the mobile codebase that touches Stages 0-2 and catalog every manual cache update.

**For each mutation hook, document:**

1. **Hook name and file location** (e.g., `useConfirmFeelHeard` in `useStages.ts`)
2. **Cache key written** (the exact key used in `queryClient.setQueryData()`)
3. **Expected cache key** (cross-reference with `queryKeys.ts` to verify match)
4. **What data is written** (what fields are updated in the cache)
5. **Match?** YES if cache key matches a key that `useQuery` reads from, NO if mismatch
6. **Stage update included?** Does the `onMutate` update `myProgress.stage` when the mutation advances the stage?

**Hooks to audit (Stages 0-2):**

From `useSessions.ts`:
- `useCreateSession` -- cache update for session list
- `useConfirmInvitationMessage` -- cache update for invitation state, stage advance
- `useAcceptInvitation` -- cache update for session state

From `useStages.ts`:
- `useSignCompact` -- cache update for compact status
- `useConfirmFeelHeard` -- cache update for milestone timestamp, stage advance to PERSPECTIVE_STRETCH
- `useConsentToShareEmpathy` -- cache update for empathy status
- `useSaveDraft` / `useSubmitEmpathyDraft` -- cache update for empathy draft
- `useValidateEmpathy` -- cache update for validation result
- `useRespondToShareSuggestion` -- cache update for share offer state
- Any other Stage 2 mutations found

From `useMessages.ts`:
- `useSendMessage` -- optimistic message add to cache
- Message streaming cache updates in `useStreamingMessage.ts`

**Format as a table:**

| Hook | File:Line | Cache Key Written | Expected Key | Match? | Stage Update? | Notes |
|------|-----------|-------------------|--------------|--------|---------------|-------|

Also document the `onSuccess` and `onError` handlers for each mutation:
- Does `onSuccess` call `invalidateQueries`? With which keys?
- Does `onError` restore previous data correctly?
  </action>
  <verify>The audit document contains a complete table of all mutation hooks with cache key verification for Stages 0-2.</verify>
  <done>Every mutation hook in Stages 0-2 is cataloged with cache key written, expected key, match status, and stage update status.</done>
</task>

<task type="auto">
  <name>Task 2: Audit Ably event handlers and derive cache update completeness</name>
  <files>.planning/phases/01-audit/01-04-AUDIT-CACHE-UPDATES.md</files>
  <action>
Append to the cache audit document sections covering Ably-driven cache updates and a completeness analysis.

**Sections to add:**

1. **Ably Event Handlers That Update Cache**
   - Read `mobile/src/hooks/useRealtime.ts` (829 lines)
   - For each event handler, document:
     - Event name it listens for
     - What cache key it invalidates or updates
     - Whether it uses `invalidateQueries` (refetch from server) or `setQueryData` (direct write)
     - Whether it correctly handles the partner's perspective

   Format as table:
   | Event | Handler Function | Cache Action | Cache Key | Correct? | Notes |

2. **Cache Update Completeness Analysis**
   - Cross-reference the interaction paths from Plans 01-03 with the cache updates found here
   - For each interaction path, verify: does the acting user's cache update correctly? Does the partner's cache update correctly via Ably handler?
   - Flag any interaction path where a cache update is missing or writes to wrong key

3. **UI State Derivation Audit**
   - Read `mobile/src/utils/chatUIState.ts` and `mobile/src/hooks/useChatUIState.ts`
   - Document which cache keys are read by `computeChatUIState()` to derive panel visibility
   - Verify these cache keys match the keys written by mutations and Ably handlers
   - Flag any cache key read by UI derivation that is never written to by any mutation or Ably handler

4. **Consolidated Issues**
   - Merge all cache-related issues from this audit and the three prior stage audits
   - Prioritize by severity:
     - Critical: Cache key mismatch (writes go to wrong key), missing stage update in mutation
     - Medium: Missing invalidation, stale data risk
     - Low: Redundant invalidation, minor optimization opportunities

5. **Cross-Phase Issue Summary**
   - Compile the FINAL consolidated list of all issues found across all four audit plans
   - Group by category: Cache Updates, Stage Transitions, Reconciler, Ably Events, UI State
   - This becomes the authoritative issue list for Phase 2+ planning
  </action>
  <verify>The audit document contains Ably handler inventory, completeness analysis, UI state derivation audit, and cross-phase issue summary.</verify>
  <done>Cache update audit is complete: every manual cache write inventoried, every Ably handler mapped, completeness verified against interaction paths, UI derivation verified against cache writes, and a final consolidated issue list compiled across all four audit plans.</done>
</task>

</tasks>

<verification>
1. `.planning/phases/01-audit/01-04-AUDIT-CACHE-UPDATES.md` exists and is comprehensive
2. All mutation hooks in Stages 0-2 cataloged with cache key verification
3. All Ably event handlers mapped with cache actions
4. Completeness analysis cross-references interaction paths from Plans 01-03
5. UI state derivation audit verifies cache reads match cache writes
6. Final consolidated issue list compiled across all four audits
</verification>

<success_criteria>
- Complete inventory of every manual cache update in mutation hooks for Stages 0-2
- Each cache update verified against queryKeys.ts for correctness
- Every Ably event handler mapped with its cache action
- Completeness analysis identifies any interaction path with missing cache updates
- UI state derivation inputs verified against available cache writes
- Final cross-phase issue summary provides authoritative list for future phases
</success_criteria>

<output>
After completion, create `.planning/phases/01-audit/01-04-SUMMARY.md`
</output>
