---
phase: 02-test-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - e2e/playwright.two-browser.config.ts
  - e2e/tests/two-browser-smoke.spec.ts
autonomous: false

must_haves:
  truths:
    - "Two browser contexts connect to the same session via real Ably"
    - "Mocked LLM responses use per-user TypeScript fixtures for deterministic AI interactions"
    - "Tests navigate full UI from scratch (no DB seeding via SessionBuilder)"
    - "Infrastructure supports writing tests for any stage transition or partner interaction"
  artifacts:
    - path: "e2e/playwright.two-browser.config.ts"
      provides: "Playwright config for two-browser tests with MOCK_LLM=true and no global fixture ID"
      exports: ["default"]
    - path: "e2e/tests/two-browser-smoke.spec.ts"
      provides: "Smoke test proving two-browser infrastructure works end-to-end"
      contains: "TwoBrowserHarness"
  key_links:
    - from: "e2e/tests/two-browser-smoke.spec.ts"
      to: "e2e/helpers/two-browser-harness.ts"
      via: "import TwoBrowserHarness, waitForPartnerUpdate"
      pattern: "TwoBrowserHarness"
    - from: "e2e/tests/two-browser-smoke.spec.ts"
      to: "e2e/helpers/test-utils.ts"
      via: "import signCompact, handleMoodCheck, waitForAIResponse, sendAndWaitForPanel"
      pattern: "signCompact|handleMoodCheck"
    - from: "e2e/playwright.two-browser.config.ts"
      to: "backend webServer"
      via: "MOCK_LLM=true, E2E_AUTH_BYPASS=true, no E2E_FIXTURE_ID"
      pattern: "MOCK_LLM.*true"
---

<objective>
Create a Playwright config for two-browser tests and a smoke test that proves the entire infrastructure works: two users connect to the same session, navigate full UI (compact, mood check), User A chats with AI using fixtures, and both users see each other's partner name via Ably.

Purpose: This validates that TwoBrowserHarness, per-user fixtures, real Ably, and full UI navigation all work together. It also serves as a template for Phase 3-4 test authors.
Output: `e2e/playwright.two-browser.config.ts` and `e2e/tests/two-browser-smoke.spec.ts`.
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-test-infrastructure/02-RESEARCH.md
@.planning/phases/02-test-infrastructure/02-01-SUMMARY.md

# Config pattern to follow:
@e2e/playwright.config.ts
@e2e/playwright.live-ai.config.ts
# Existing two-browser test (pattern reference, not to replicate):
@e2e/tests/partner-journey.spec.ts
# Fixture files:
@backend/src/fixtures/user-a-full-journey.ts
@backend/src/fixtures/user-b-partner-journey.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create two-browser Playwright config</name>
  <files>e2e/playwright.two-browser.config.ts</files>
  <action>
Create `e2e/playwright.two-browser.config.ts` following the pattern of `playwright.live-ai.config.ts` but for two-browser tests:

Key differences from the main `playwright.config.ts`:
1. **No global `E2E_FIXTURE_ID`** in the webServer env. The per-request `X-E2E-Fixture-ID` headers (set by TwoBrowserHarness via createUserContext) handle fixture selection per user. This is critical to avoid the "all users get same fixture" pitfall from RESEARCH.md.
2. `MOCK_LLM: 'true'` (deterministic AI responses from fixtures).
3. `E2E_AUTH_BYPASS: 'true'` (bypass Clerk auth).
4. `testMatch` matches `two-browser-*.spec.ts` glob pattern.
5. Timeout: 300000 (5 minutes per test, same as partner-journey).
6. Single project named `two-browser`.
7. `fullyParallel: false`, `workers: 1` (sequential, same as main config).
8. Same webServer array pattern as main config (backend + mobile Expo web).
9. Same globalSetup as main config.
10. Output dir: `test-results/`.

Run command will be: `cd e2e && npx playwright test --config=playwright.two-browser.config.ts`
  </action>
  <verify>
Read the created file and verify: no E2E_FIXTURE_ID in webServer env, MOCK_LLM is 'true', testMatch covers two-browser-*.spec.ts files.
  </verify>
  <done>
`e2e/playwright.two-browser.config.ts` exists with correct webServer config (MOCK_LLM=true, no global fixture ID), matching two-browser test files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create two-browser smoke test</name>
  <files>e2e/tests/two-browser-smoke.spec.ts</files>
  <action>
Create `e2e/tests/two-browser-smoke.spec.ts` that proves the full infrastructure works.

The test should:

**Setup (beforeEach):**
1. Create TwoBrowserHarness with config:
   - User A: `{ email: 'smoke-a@e2e.test', name: 'Alice', fixtureId: 'user-a-full-journey' }`
   - User B: `{ email: 'smoke-b@e2e.test', name: 'Bob', fixtureId: 'user-b-partner-journey' }`
2. Call `harness.cleanup()` to clean DB.
3. Call `harness.setupUserA(browser, request)` to seed User A and create context.
4. Call `harness.createSession()` to create session via API (with inviteName 'Bob').

Note: User B setup happens AFTER User A creates session (sequential, not parallel - per RESEARCH.md Pitfall 5).

**Teardown (afterEach):**
Call `harness.teardown()` to close contexts.

**Test: "both users can connect and navigate UI":**
1. Set timeout to 300000 (5 minutes).
2. Call `harness.setupUserB(browser, request)` to seed User B and create context.
3. Accept invitation: `POST /api/invitations/{harness.invitationId}/accept` with User B's headers. The harness's `createSession()` must store `invitationId` from the session creation response. If not available, modify the harness to expose it before proceeding.
4. Navigate User A to session: `harness.navigateUserA()`.
5. User A signs compact: `signCompact(harness.userAPage)`.
6. User A handles mood check: `handleMoodCheck(harness.userAPage)`.
7. User A sees chat input: `expect(harness.userAPage.getByTestId('chat-input')).toBeVisible()`.
8. Navigate User B to session: `harness.navigateUserB()`.
9. User B signs compact: `signCompact(harness.userBPage)`.
10. User B handles mood check: `handleMoodCheck(harness.userBPage)`.
11. User B sees chat input: `expect(harness.userBPage.getByTestId('chat-input')).toBeVisible()`.
12. **Verify User A sees partner name:** `expect(harness.userAPage.getByTestId('session-chat-header-partner-name')).toHaveText('Bob')` (with timeout 15000 - Ably update may be needed). If flaky, use `waitForPartnerUpdate()` with reload fallback.
13. **Verify User B sees partner name:** `expect(harness.userBPage.getByTestId('session-chat-header-partner-name')).toHaveText('Alice')` (with timeout 15000).
14. **Verify User A gets fixture responses:** User A sends first message (`"Hi, I'm having a conflict with my partner"`) via chat input + send button, waits for AI response matching `/glad you reached out/i` (from user-a-full-journey fixture response 0). Use `waitForAIResponse()`.
15. **Verify User B gets DIFFERENT fixture responses:** User B sends first message (`"Things have been tense lately"`) via chat input + send button, waits for AI response matching `/tension can be really draining/i` (from user-b-partner-journey fixture response 0). Use `waitForAIResponse()`.

This proves:
- Two browser contexts work independently
- Per-user fixtures deliver different AI responses
- Real Ably connects both users to same session
- Full UI navigation works (no SessionBuilder shortcuts)

Important notes:
- Import `test` from `@playwright/test` (not from a fixture file).
- Use `test.describe` and `test` blocks.
- Use `devices['iPhone 12']` via `test.use(devices['iPhone 12'])`.
- The partner name might need Ably update time. Use timeout of 15000ms. If still flaky, wrap with `waitForPartnerUpdate()`.
- User A creates session with `inviteName: 'Bob'`. User B accepts invitation via API after being seeded.
- The correct sequence is: setupUserA -> createSession -> setupUserB -> acceptInvitation -> navigateUserA -> navigateUserB.
- Do NOT use SessionBuilder anywhere in this test.
  </action>
  <verify>
Run the smoke test: `cd /Users/shantam/Software/meet-without-fear/e2e && npx playwright test --config=playwright.two-browser.config.ts tests/two-browser-smoke.spec.ts --timeout 300000`

The test should pass with both users connecting, signing compact, seeing each other's partner name, and receiving different fixture-based AI responses.
  </verify>
  <done>
Smoke test passes: Both users connect to same session via real Ably, navigate full UI (compact + mood check), see each other's partner name, and receive different AI responses from per-user fixtures. No SessionBuilder seeding used.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify two-browser infrastructure works end-to-end</name>
  <files>e2e/tests/two-browser-smoke.spec.ts</files>
  <action>
Human verifies the smoke test results. No code changes needed - this is a verification checkpoint.
  </action>
  <verify>
User confirms the smoke test output shows both users connected and chatting successfully.
  </verify>
  <done>
User approves the two-browser infrastructure after reviewing test results.
  </done>
  <what-built>
Two-browser E2E test infrastructure: TwoBrowserHarness class, waitForPartnerUpdate helper, Playwright config for two-browser tests, and a smoke test proving everything works.
  </what-built>
  <how-to-verify>
1. Check the test output from the smoke test run (should show both users connecting and chatting)
2. Optionally run in headed mode to see both browser windows: `cd e2e && npx playwright test --config=playwright.two-browser.config.ts tests/two-browser-smoke.spec.ts --headed`
3. Verify the test-results/ directory has screenshots from both users
4. Confirm the smoke test does NOT use SessionBuilder (grep for "SessionBuilder" in the test file should return nothing)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `e2e/playwright.two-browser.config.ts` has no global E2E_FIXTURE_ID, uses MOCK_LLM=true
2. `e2e/tests/two-browser-smoke.spec.ts` uses TwoBrowserHarness, not SessionBuilder
3. Smoke test proves: two contexts connect, per-user fixtures work, Ably delivers partner updates, full UI navigation works
4. Test passes end-to-end
5. No existing tests are broken (main playwright.config.ts unchanged)
</verification>

<success_criteria>
- Smoke test passes proving two-browser infrastructure works
- Two browser contexts connect to same session via real Ably
- Each user gets different AI responses from per-user fixtures
- Full UI navigation (compact, mood check, chat) works for both users
- Infrastructure is ready for Phase 3-4 test authoring
</success_criteria>

<output>
After completion, create `.planning/phases/02-test-infrastructure/02-02-SUMMARY.md`
</output>
