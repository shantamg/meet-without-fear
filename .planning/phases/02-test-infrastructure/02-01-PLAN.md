---
phase: 02-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - e2e/helpers/two-browser-harness.ts
  - e2e/helpers/index.ts
autonomous: true

must_haves:
  truths:
    - "Two browser contexts can connect to the same session via real Ably"
    - "Each browser context gets its own fixture ID for deterministic AI responses"
    - "Tests can wait for cross-context Ably events with timeout + reload fallback"
    - "Context lifecycle is properly managed (setup and teardown without leaks)"
  artifacts:
    - path: "e2e/helpers/two-browser-harness.ts"
      provides: "TwoBrowserHarness class + waitForPartnerUpdate helper"
      exports: ["TwoBrowserHarness", "waitForPartnerUpdate"]
    - path: "e2e/helpers/index.ts"
      provides: "Re-exports for new harness"
      contains: "TwoBrowserHarness"
  key_links:
    - from: "e2e/helpers/two-browser-harness.ts"
      to: "e2e/helpers/auth.ts"
      via: "import getE2EHeaders"
      pattern: "getE2EHeaders"
    - from: "e2e/helpers/two-browser-harness.ts"
      to: "e2e/helpers/cleanup.ts"
      via: "import cleanupE2EData"
      pattern: "cleanupE2EData"
    - from: "e2e/helpers/two-browser-harness.ts"
      to: "e2e/helpers/test-utils.ts"
      via: "import createUserContext"
      pattern: "createUserContext"
---

<objective>
Create the TwoBrowserHarness class and waitForPartnerUpdate helper that form the core infrastructure for two-browser E2E testing with per-user fixtures and Ably event synchronization.

Purpose: This is the foundational building block. All Phase 3-4 two-browser tests will use this harness to manage browser contexts, fixtures, and cross-context event waiting.
Output: `e2e/helpers/two-browser-harness.ts` with TwoBrowserHarness class and waitForPartnerUpdate helper, updated `e2e/helpers/index.ts` with re-exports.
</objective>

<execution_context>
@/Users/shantam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shantam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-test-infrastructure/02-RESEARCH.md

# Existing infrastructure to build on:
@e2e/helpers/auth.ts
@e2e/helpers/cleanup.ts
@e2e/helpers/test-utils.ts
@e2e/helpers/index.ts
@e2e/helpers/session-builder.ts
# Existing two-browser pattern to follow:
@e2e/tests/partner-journey.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TwoBrowserHarness class and waitForPartnerUpdate helper</name>
  <files>e2e/helpers/two-browser-harness.ts</files>
  <action>
Create `e2e/helpers/two-browser-harness.ts` with the following:

**TwoBrowserHarness class:**

The class manages two isolated browser contexts (User A and User B) with per-user fixture IDs. It reuses existing `createUserContext()` from `test-utils.ts` and `getE2EHeaders()` from `auth.ts`.

Constructor takes config:
```typescript
export interface TwoBrowserConfig {
  userA: { email: string; name: string; fixtureId: string };
  userB: { email: string; name: string; fixtureId: string };
  apiBaseUrl?: string;  // defaults to process.env.API_BASE_URL || 'http://localhost:3000'
  appBaseUrl?: string;  // defaults to process.env.APP_BASE_URL || 'http://localhost:8082'
}
```

Methods:
- `async setupUserA(browser: Browser, request: APIRequestContext): Promise<void>` - Seeds User A via `POST /api/e2e/seed` with `{ email, name }` body, creates browser context with User A's fixture via `createUserContext()`. Stores `userAPage`, `userAContext`, `userAId` as public properties. Stores `request` as private property for later API calls.
- `async setupUserB(browser: Browser, request: APIRequestContext): Promise<void>` - Seeds User B via `POST /api/e2e/seed`, creates browser context with User B's fixture via `createUserContext()`. Stores `userBPage`, `userBContext`, `userBId` as public properties.
- `async createSession(): Promise<string>` - Creates a session via `POST /api/sessions` with `{ inviteName: config.userB.name }` using User A's E2E headers (including fixture ID). Parses the response to extract `session.id` and `invitation.id` from `data` envelope. Sets `this.sessionId` and `this.invitationId`. Returns the session ID.
- `async acceptInvitation(): Promise<void>` - Accepts the invitation via `POST /api/invitations/{invitationId}/accept` using User B's E2E headers (including fixture ID). Requires `setupUserB` and `createSession` to have been called first. Uses the stored `request` APIRequestContext.
- `async navigateUserA(): Promise<void>` - Navigates User A to the session using `navigateToSession()` from test-utils.
- `async navigateUserB(): Promise<void>` - Navigates User B to the session using `navigateToSession()` from test-utils.
- `async teardown(): Promise<void>` - Closes both browser contexts. Safe to call if contexts were never created (checks for null/undefined).
- `async cleanup(): Promise<void>` - Calls `cleanupE2EData()` to reset DB state. Call in `beforeEach` before setup.

Public properties (set during setup, typed as assertions):
- `userAPage: Page`
- `userAContext: BrowserContext`
- `userAId: string`
- `userBPage: Page`
- `userBContext: BrowserContext`
- `userBId: string`
- `sessionId: string`
- `invitationId: string`
- `config: TwoBrowserConfig` (read-only access to the config)

Important implementation details:
1. User seeding uses `POST /api/e2e/seed` with `{ email, name }` body. The response is `{ id: string }` (see single-user-journey.spec.ts line 63-71 for pattern). Use the stored `request` for API calls.
2. Session creation uses `POST /api/sessions` with `{ inviteName: 'PartnerName' }` body and User A's E2E headers including fixture ID. Response format: `{ success: true, data: { session: { id }, invitation: { id } } }` (see single-user-journey.spec.ts line 88 for pattern). Must store BOTH `sessionId` and `invitationId`.
3. Invitation acceptance uses `POST /api/invitations/{invitationId}/accept` with User B's E2E headers including fixture ID (see partner-journey.spec.ts line 202 for pattern).
4. Use `createUserContext()` from test-utils.ts for context creation (it already handles devices['iPhone 12'], headers, and positioning).
5. Position User A at `{ x: 0, y: 0 }` and User B at `{ x: 450, y: 0 }` for headed mode debugging (same as partner-journey.spec.ts).
6. The `request` parameter comes from Playwright's `APIRequestContext` fixture. Store it in `setupUserA` for use by `createSession` and `acceptInvitation`.
7. Do NOT use SessionBuilder -- the whole point is navigating full UI from scratch.
8. Store `apiBaseUrl` and `appBaseUrl` as private properties with defaults.
9. Each user's API calls (seed, create session, accept invitation) must include their E2E headers with fixture ID via `getE2EHeaders(email, userId, fixtureId)`.
10. For `createSession` and `acceptInvitation`, use the stored Playwright `request` object since it handles headers correctly. Add E2E headers + Content-Type to each request.

**waitForPartnerUpdate helper (standalone exported function):**

```typescript
export async function waitForPartnerUpdate(
  page: Page,
  locator: Locator,
  options?: {
    timeout?: number;      // default: 8000ms
    reloadOnMiss?: boolean; // default: true
  }
): Promise<boolean>
```

Pattern (from partner-journey.spec.ts lines 440-477):
1. Check if locator is visible within timeout using `locator.isVisible({ timeout })`.catch(() => false).
2. If visible, return `true`.
3. If not visible and `reloadOnMiss` is true:
   a. Reload the page via `page.reload()`.
   b. Wait for `networkidle` via `page.waitForLoadState('networkidle')`.
   c. Call `handleMoodCheck(page)` (mood check can reappear after reload).
   d. Check locator visibility again with same timeout.
4. Return final visibility state.

The caller can then `expect(result).toBe(true)` or handle accordingly.

Import `handleMoodCheck` from `./test-utils` for the reload fallback.
  </action>
  <verify>
Run `cd /Users/shantam/Software/meet-without-fear/e2e && npx tsc --noEmit --project tsconfig.json 2>&1 | head -30` to verify TypeScript compilation. If no tsconfig.json exists in e2e/, run `npx tsc --noEmit e2e/helpers/two-browser-harness.ts --esModuleInterop --module commonjs --target es2020 --moduleResolution node --skipLibCheck` or verify by checking imports resolve correctly.
  </verify>
  <done>
`e2e/helpers/two-browser-harness.ts` exists with TwoBrowserHarness class (setupUserA, setupUserB, createSession, acceptInvitation, navigateUserA, navigateUserB, teardown, cleanup methods) and waitForPartnerUpdate function. Class exposes sessionId, invitationId, userAId, userBId, userAPage, userBPage, config. File compiles without TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update helpers index to re-export new harness</name>
  <files>e2e/helpers/index.ts</files>
  <action>
Add re-exports for TwoBrowserHarness and waitForPartnerUpdate to `e2e/helpers/index.ts`:

```typescript
export { TwoBrowserHarness, waitForPartnerUpdate } from './two-browser-harness';
export type { TwoBrowserConfig } from './two-browser-harness';
```

Add these lines after the existing exports. Keep all existing exports unchanged.
  </action>
  <verify>
Read `e2e/helpers/index.ts` and confirm it includes the new exports alongside all existing ones.
  </verify>
  <done>
`e2e/helpers/index.ts` re-exports TwoBrowserHarness, waitForPartnerUpdate, and TwoBrowserConfig type. All prior exports remain.
  </done>
</task>

</tasks>

<verification>
1. `e2e/helpers/two-browser-harness.ts` exists and exports TwoBrowserHarness class + waitForPartnerUpdate function
2. `e2e/helpers/index.ts` re-exports both
3. TypeScript compiles without errors
4. TwoBrowserHarness uses createUserContext() from test-utils (not reimplementing)
5. TwoBrowserHarness uses getE2EHeaders() from auth.ts (not reimplementing)
6. waitForPartnerUpdate includes reload fallback + handleMoodCheck pattern
7. No SessionBuilder usage in TwoBrowserHarness
8. createSession stores both sessionId and invitationId
9. acceptInvitation uses stored invitationId and User B's headers
</verification>

<success_criteria>
- TwoBrowserHarness class creates two isolated browser contexts with per-user fixture IDs
- createSession stores sessionId and invitationId from API response
- acceptInvitation method accepts invitation using User B's headers
- waitForPartnerUpdate handles Ably event timing with reload fallback
- All code compiles without TypeScript errors
- Existing helpers/exports are not broken
</success_criteria>

<output>
After completion, create `.planning/phases/02-test-infrastructure/02-01-SUMMARY.md`
</output>
