generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// ============================================================================
// Core Models
// ============================================================================

model User {
  id                       String    @id @default(cuid())
  clerkId                  String?   @unique // Clerk authentication user ID
  email                    String    @unique
  name                     String?   // Full name (computed from firstName + lastName)
  firstName                String?
  lastName                 String?
  pushToken                String?   // Expo push token for realtime fallbacks
  biometricEnabled         Boolean   @default(false)
  biometricEnrolledAt      DateTime?
  memoryPreferences        Json?     // MemoryPreferencesDTO - AI memory settings
  notificationPreferences  Json?     // NotificationPreferencesDTO - notification settings
  lastMoodIntensity        Int?      // Last mood intensity (1-10) for session entry default
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  // Relationships
  relationships       RelationshipMember[]
  vessels             UserVessel[]
  stageProgress       StageProgress[]
  messages            Message[]
  consentsGiven       ConsentRecord[]               @relation("ConsentsGiven")
  consentsRequested   ConsentRecord[]               @relation("ConsentsRequested")
  consentedContent    ConsentedContent[]
  empathyDrafts       EmpathyDraft[]
  empathyAttempts     EmpathyAttempt[]
  empathyValidations  EmpathyValidation[]
  strategyProposals   StrategyProposal[]
  strategyRankings    StrategyRanking[]
  exerciseCompletions EmotionalExerciseCompletion[]
  invitationsSent     Invitation[]                  @relation("InvitedBy")
  innerWorkSessions   InnerWorkSession[]
  notifications       Notification[]
  userMemories        UserMemory[]
}

model Relationship {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Members (exactly 2 for Meet Without Fear)
  members  RelationshipMember[]
  sessions Session[]
}

model RelationshipMember {
  id             String       @id @default(cuid())
  relationship   Relationship @relation(fields: [relationshipId], references: [id], onDelete: Cascade)
  relationshipId String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  joinedAt       DateTime     @default(now())
  role           String       @default("member")
  nickname       String?      // What this member calls their partner

  @@unique([relationshipId, userId])
  @@index([userId])
}

// ============================================================================
// Session
// ============================================================================

model Session {
  id             String        @id @default(cuid())
  relationship   Relationship  @relation(fields: [relationshipId], references: [id], onDelete: Cascade)
  relationshipId String
  status         SessionStatus @default(CREATED)
  type           SessionType   @default(CONFLICT_RESOLUTION)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  resolvedAt     DateTime?

  // Related entities
  messages            Message[]
  sharedVessel        SharedVessel?
  stageProgress       StageProgress[]
  userVessels         UserVessel[]
  empathyDrafts       EmpathyDraft[]
  empathyAttempts     EmpathyAttempt[]
  empathyValidations  EmpathyValidation[]
  strategyProposals   StrategyProposal[]
  strategyRankings    StrategyRanking[]
  consentRecords      ConsentRecord[]
  exerciseCompletions EmotionalExerciseCompletion[]
  invitations         Invitation[]
  notifications       Notification[]
  userMemories        UserMemory[]

  // Linked Inner Thoughts sessions for private reflection during partner session
  linkedInnerThoughts InnerWorkSession[] @relation("LinkedInnerThoughts")

  @@index([relationshipId])
  @@index([status])
  @@index([type])
}

enum SessionType {
  CONFLICT_RESOLUTION // Partner-based conflict resolution (4-stage process)
  INNER_WORK // Solo self-reflection and pattern recognition
}

enum SessionStatus {
  CREATED // Invitation sent
  INVITED // Partner invited, awaiting join
  ACTIVE // Both users engaged
  PAUSED // Cooling period
  WAITING // One user ahead, waiting for other
  RESOLVED // Process completed
  ABANDONED // Timeout or withdrawal
  ARCHIVED // User has archived this session
}

// ============================================================================
// Inner Work Session (Solo Self-Reflection)
// ============================================================================

model InnerWorkSession {
  id        String              @id @default(cuid())
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  title     String?             // Optional user-provided or AI-generated title
  summary   String?             @db.Text // AI-generated summary of the session
  theme     String?             // Detected theme (e.g., "anxiety", "relationship patterns")
  status    InnerWorkStatus     @default(ACTIVE)
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  // Rolling conversation summary for long sessions (like partner session vessels)
  // Stores JSON: { text, keyThemes, emotionalJourney, unresolvedTopics, messageCount, generatedAt }
  conversationSummary String? @db.Text

  // Messages in this inner work session
  messages InnerWorkMessage[]

  // Link to partner session for context-aware Inner Thoughts
  // When set, AI has access to partner session context and can reference it
  linkedPartnerSession   Session? @relation("LinkedInnerThoughts", fields: [linkedPartnerSessionId], references: [id], onDelete: SetNull)
  linkedPartnerSessionId String?
  linkedAtStage          Int?     // Stage when Inner Thoughts was opened (1, 2, 3, 4)
  linkedTrigger          String?  // Why it was opened: "empathy_wait", "voluntary", "witness_wait"

  @@index([userId, updatedAt])
  @@index([status])
  @@index([linkedPartnerSessionId])
}

enum InnerWorkStatus {
  ACTIVE    // Ongoing inner work session
  COMPLETED // User marked as complete or AI determined closure
  ARCHIVED  // User archived this session
}

model InnerWorkMessage {
  id        String           @id @default(cuid())
  session   InnerWorkSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  role      MessageRole
  content   String           @db.Text
  timestamp DateTime         @default(now())

  // Embedding for semantic search and cross-session retrieval
  embedding Unsupported("vector(1024)")?

  @@index([sessionId, timestamp])
}

// ============================================================================
// Stage Progress
// ============================================================================

model StageProgress {
  id          String      @id @default(cuid())
  session     Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId   String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  stage       Int
  status      StageStatus @default(IN_PROGRESS)
  startedAt   DateTime    @default(now())
  completedAt DateTime?

  // Gate satisfaction tracking
  gatesSatisfied Json? // Stage-specific gate conditions

  // Synthesis cache invalidation
  isSynthesisDirty     Boolean   @default(true)
  synthesisLastUpdated DateTime?

  @@unique([sessionId, userId, stage])
  @@index([sessionId])
  @@index([userId])
}

enum StageStatus {
  NOT_STARTED
  IN_PROGRESS
  GATE_PENDING // Requirements met, awaiting partner
  COMPLETED
}

// ============================================================================
// User Vessel (Private Data)
// ============================================================================

model UserVessel {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Private content
  events            UserEvent[]
  emotionalReadings EmotionalReading[]
  identifiedNeeds   IdentifiedNeed[]
  boundaries        Boundary[]
  documents         UserDocument[]

  // Rolling conversation summary for long sessions
  // Stores JSON with: text, keyThemes, emotionalJourney, unresolvedTopics
  conversationSummary String? @db.Text

  // Embedding for semantic search within user's own content
  embedding Unsupported("vector(1024)")?

  @@unique([userId, sessionId])
  @@index([userId])
  @@index([sessionId])
}

model UserEvent {
  id           String      @id @default(cuid())
  vessel       UserVessel  @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId     String
  description  String      @db.Text
  attributedTo Attribution
  emotions     String[]
  timestamp    DateTime    @default(now())

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  @@index([vesselId, timestamp])
}

enum Attribution {
  SELF
  OTHER
  MUTUAL
  EXTERNAL
}

model EmotionalReading {
  id        String     @id @default(cuid())
  vessel    UserVessel @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId  String
  intensity Int // 1-10 scale
  context   String?    @db.Text
  stage     Int // Stage when reading was taken
  timestamp DateTime   @default(now())

  @@index([vesselId, timestamp])
}

model IdentifiedNeed {
  id           String       @id @default(cuid())
  vessel       UserVessel   @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId     String
  need         String // From universal needs taxonomy
  category     NeedCategory
  evidence     String[] // Quotes/references supporting this need
  confirmed    Boolean      @default(false) // User confirmed this need
  aiConfidence Float // AI confidence in identification
  createdAt    DateTime     @default(now())

  // Link to shared version if consented
  consentedContent ConsentedContent?

  @@index([vesselId])
}

enum NeedCategory {
  SAFETY
  CONNECTION
  AUTONOMY
  RECOGNITION
  MEANING
  FAIRNESS
}

model Boundary {
  id            String     @id @default(cuid())
  vessel        UserVessel @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId      String
  description   String     @db.Text
  nonNegotiable Boolean    @default(false)
  createdAt     DateTime   @default(now())

  @@index([vesselId])
}

model UserDocument {
  id        String     @id @default(cuid())
  vessel    UserVessel @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId  String
  title     String
  content   String     @db.Text
  type      String // e.g., "reflection", "journal", "note"
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@index([vesselId])
}

// ============================================================================
// Shared Vessel (Consensual Data)
// ============================================================================

model SharedVessel {
  id        String   @id @default(cuid())
  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Shared content
  consentedContent ConsentedContent[]
  commonGround     CommonGround[]
  agreements       Agreement[]
}

model ConsentedContent {
  id                 String          @id @default(cuid())
  sharedVessel       SharedVessel    @relation(fields: [sharedVesselId], references: [id], onDelete: Cascade)
  sharedVesselId     String
  sourceUser         User?           @relation(fields: [sourceUserId], references: [id], onDelete: SetNull)
  sourceUserId       String?
  originalNeed       IdentifiedNeed? @relation(fields: [originalNeedId], references: [id], onDelete: SetNull)
  originalNeedId     String?         @unique
  transformedContent String          @db.Text // Heat removed, need preserved
  consentedAt        DateTime        @default(now())
  consentActive      Boolean         @default(true)
  revokedAt          DateTime?

  // Link to consent record for audit
  consentRecord   ConsentRecord @relation(fields: [consentRecordId], references: [id])
  consentRecordId String

  @@index([sharedVesselId])
  @@index([sourceUserId])
}

model CommonGround {
  id             String       @id @default(cuid())
  sharedVessel   SharedVessel @relation(fields: [sharedVesselId], references: [id], onDelete: Cascade)
  sharedVesselId String
  need           String
  category       NeedCategory
  confirmedByA   Boolean      @default(false)
  confirmedByB   Boolean      @default(false)
  confirmedAt    DateTime?

  @@index([sharedVesselId])
}

model Agreement {
  id             String            @id @default(cuid())
  sharedVessel   SharedVessel      @relation(fields: [sharedVesselId], references: [id], onDelete: Cascade)
  sharedVesselId String
  description    String            @db.Text
  type           AgreementType
  status         AgreementStatus   @default(PROPOSED)
  agreedByA      Boolean           @default(false)
  agreedByB      Boolean           @default(false)
  agreedAt       DateTime?
  followUpDate   DateTime?
  completedAt    DateTime?
  proposal       StrategyProposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  proposalId     String?

  @@index([sharedVesselId])
}

enum AgreementType {
  MICRO_EXPERIMENT // Small, reversible action
  COMMITMENT // Longer-term agreement
  CHECK_IN // Scheduled follow-up
  HYBRID // Combined elements from multiple strategies
}

enum AgreementStatus {
  PROPOSED
  AGREED
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

// ============================================================================
// Consent Management
// ============================================================================

model ConsentRecord {
  id                String             @id @default(cuid())
  user              User               @relation("ConsentsGiven", fields: [userId], references: [id], onDelete: Cascade)
  userId            String
  session           Session?           @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId         String?
  targetType        ConsentContentType
  targetId          String? // e.g., empathy draft id, need id, boundary id
  requestedBy       User               @relation("ConsentsRequested", fields: [requestedByUserId], references: [id], onDelete: Cascade)
  requestedByUserId String
  decision          ConsentDecision?
  decidedAt         DateTime?
  revokedAt         DateTime?
  metadata          Json? // Additional context
  createdAt         DateTime           @default(now())

  // Link to resulting shared content
  consentedContent ConsentedContent[]
  empathyAttempt   EmpathyAttempt[]
  strategyProposal StrategyProposal[]

  @@index([userId, sessionId, targetType, decidedAt])
}

enum ConsentContentType {
  IDENTIFIED_NEED
  EVENT_SUMMARY
  EMOTIONAL_PATTERN
  BOUNDARY
  EMPATHY_DRAFT
  EMPATHY_ATTEMPT
  STRATEGY_PROPOSAL
}

enum ConsentDecision {
  GRANTED
  DENIED
  REVOKED
}

// ============================================================================
// Messages
// ============================================================================

model Message {
  id        String      @id @default(cuid())
  session   Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  sender    User?       @relation(fields: [senderId], references: [id], onDelete: SetNull)
  senderId  String? // null for AI messages
  forUserId String? // Which user the AI was responding to (for data isolation)
  role      MessageRole
  content   String      @db.Text
  stage     Int
  timestamp DateTime    @default(now())

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  // Extracted memory references
  extractedNeeds    String[]
  extractedEmotions String[]

  @@index([sessionId, timestamp])
  @@index([senderId])
  @@index([forUserId])
}

enum MessageRole {
  USER
  AI
  SYSTEM
  EMPATHY_STATEMENT // User's shared empathy statement (shown in chat history)
}

// ============================================================================
// Pre-Session Messages
// ============================================================================

// Messages captured before a session is created or identified.
// These are associated with a session retroactively once the user
// starts or switches to a session.
model PreSessionMessage {
  id        String      @id @default(cuid())
  userId    String
  role      MessageRole
  content   String      @db.Text
  timestamp DateTime    @default(now())

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  // Metadata from intent detection
  detectedIntent    String? // The intent detected for this message
  emotionalTone     String? // neutral, upset, hopeful, anxious
  extractedPerson   String? // If a person was mentioned
  extractedTopic    String? // If a topic was identified

  // Association tracking
  associatedSessionId String?   // Set when message is linked to a session
  associatedAt        DateTime? // When it was associated

  // Cleanup
  expiresAt DateTime // Auto-cleanup after 24 hours if not associated

  @@index([userId, timestamp])
  @@index([userId, associatedSessionId])
  @@index([expiresAt])
}

// ============================================================================
// Stage 2: Empathy Attempts
// ============================================================================

model EmpathyDraft {
  id           String   @id @default(cuid())
  session      Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId    String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  content      String   @db.Text
  readyToShare Boolean  @default(false)
  version      Int      @default(1)
  updatedAt    DateTime @updatedAt
  createdAt    DateTime @default(now())

  attempts EmpathyAttempt[]

  @@unique([sessionId, userId])
}

model EmpathyAttempt {
  id              String         @id @default(cuid())
  draft           EmpathyDraft?  @relation(fields: [draftId], references: [id], onDelete: SetNull)
  draftId         String?
  session         Session        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId       String
  sourceUser      User?          @relation(fields: [sourceUserId], references: [id], onDelete: SetNull)
  sourceUserId    String?
  content         String         @db.Text
  sharedAt        DateTime       @default(now())
  consentRecord   ConsentRecord? @relation(fields: [consentRecordId], references: [id], onDelete: SetNull)
  consentRecordId String?

  validations EmpathyValidation[]

  @@index([sessionId, sourceUserId])
}

model EmpathyValidation {
  id             String         @id @default(cuid())
  attempt        EmpathyAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  attemptId      String
  session        Session        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId      String
  user           User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId         String? // Recipient validating partner attempt (null if user deleted)
  validated      Boolean
  feedback       String?        @db.Text
  feedbackShared Boolean        @default(false)
  validatedAt    DateTime?      @default(now())

  @@unique([attemptId, userId])
}

// ============================================================================
// Post-Stage 2: Empathy Reconciler
// ============================================================================

/// Stores the result of reconciler analysis comparing what one person
/// guessed about the other vs what they actually expressed.
model ReconcilerResult {
  id        String   @id @default(cuid())
  sessionId String

  /// The user who made the empathy guess
  guesserId     String
  guesserName   String
  /// The user being guessed about (whose feelings were analyzed)
  subjectId     String
  subjectName   String

  // Alignment Analysis
  alignmentScore     Int      // 0-100
  alignmentSummary   String   @db.Text
  correctlyIdentified String[] // Feelings/needs that were correctly identified

  // Gap Analysis
  gapSeverity       String   // none, minor, moderate, significant
  gapSummary        String   @db.Text
  missedFeelings    String[] // Feelings/needs that were missed
  misattributions   String[] // Incorrect assumptions made
  mostImportantGap  String?  @db.Text // The single most important gap

  // Recommendation
  recommendedAction   String  // PROCEED, OFFER_OPTIONAL, OFFER_SHARING
  rationale           String  @db.Text
  sharingWouldHelp    Boolean
  suggestedShareFocus String? @db.Text

  createdAt DateTime @default(now())

  // Relationship to share offer
  shareOffer ReconcilerShareOffer?

  @@unique([sessionId, guesserId, subjectId])
  @@index([sessionId])
}

/// Tracks the share offer made to a user and their response.
model ReconcilerShareOffer {
  id        String   @id @default(cuid())
  result    ReconcilerResult @relation(fields: [resultId], references: [id], onDelete: Cascade)
  resultId  String   @unique

  /// The user being asked to share (the subject of the analysis)
  userId    String

  /// Status of the share offer
  status    ReconcilerShareStatus @default(NOT_OFFERED)

  /// The AI-generated message offering to share
  offerMessage      String?  @db.Text
  /// Quote options extracted from their witnessing
  quoteOptions      Json?    // Array of QuoteOption objects
  recommendedQuote  Int?     // Index of recommended quote

  /// If they accepted, what was shared
  sharedContent     String?  @db.Text
  sharedAt          DateTime?

  /// If they declined or skipped
  declinedAt        DateTime?
  skippedAt         DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status])
}

enum ReconcilerShareStatus {
  NOT_OFFERED
  OFFERED
  ACCEPTED
  DECLINED
  SKIPPED
}

// ============================================================================
// Stage 4: Strategies and Rankings
// ============================================================================

model StrategyProposal {
  id               String         @id @default(cuid())
  session          Session        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId        String
  createdBy        User?          @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdByUserId  String?
  description      String         @db.Text
  needsAddressed   String[]
  duration         String?
  measureOfSuccess String?
  source           StrategySource @default(USER_SUBMITTED)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  consentRecord    ConsentRecord? @relation(fields: [consentRecordId], references: [id], onDelete: SetNull)
  consentRecordId  String?

  // Note: Rankings reference proposals via rankedIds (String[]), not a direct relation
  agreements Agreement[]

  @@index([sessionId])
}

enum StrategySource {
  USER_SUBMITTED
  AI_SUGGESTED
  CURATED
}

model StrategyRanking {
  id          String   @id @default(cuid())
  session     Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId   String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  rankedIds   String[] // Ordered StrategyProposal ids
  submittedAt DateTime @default(now())

  @@unique([sessionId, userId])
}

// ============================================================================
// Emotional Regulation
// ============================================================================

model EmotionalExerciseCompletion {
  id              String       @id @default(cuid())
  session         Session      @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId       String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  type            ExerciseType
  completedAt     DateTime     @default(now())
  intensityBefore Int?
  intensityAfter  Int?

  @@index([sessionId, userId, completedAt])
}

enum ExerciseType {
  BREATHING_EXERCISE
  BODY_SCAN
  GROUNDING
  PAUSE_SESSION
}

// ============================================================================
// Global Library (Stage 4 Suggestions)
// ============================================================================

model GlobalLibraryItem {
  id          String              @id @default(cuid())
  title       String
  description String              @db.Text
  category    String // e.g., "communication", "quality-time", "conflict-resolution"
  source      GlobalLibrarySource
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  // For user-contributed items only
  contributedBy       String? // User ID if contributed (anonymized in results)
  contributionConsent DateTime? // When user consented to anonymized contribution

  @@index([category])
  @@index([source])
}

enum GlobalLibrarySource {
  CURATED // Admin/expert authored
  CONTRIBUTED // User-contributed with explicit consent
}

// ============================================================================
// Invitations
// ============================================================================

model Invitation {
  id                String           @id @default(cuid())
  session           Session          @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId         String
  invitedBy         User             @relation("InvitedBy", fields: [invitedById], references: [id], onDelete: Cascade)
  invitedById       String
  name              String?          // Display name for the invited person
  invitationMessage   String?          @db.Text // The crafted invitation message
  messageConfirmed    Boolean          @default(false) // User confirmed the message
  messageConfirmedAt  DateTime?        // When the user confirmed the message (for chat indicator positioning)
  status              InvitationStatus @default(PENDING)
  createdAt         DateTime         @default(now())
  expiresAt         DateTime
  acceptedAt        DateTime?
  declinedAt        DateTime?
  declineReason     String?
  notifications     Notification[]

  @@index([sessionId])
  @@index([status])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

// ============================================================================
// Notifications
// ============================================================================

model Notification {
  id           String           @id @default(cuid())
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  type         NotificationType
  title        String
  body         String           @db.Text
  read         Boolean          @default(false)
  session      Session?         @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  sessionId    String?
  invitation   Invitation?      @relation(fields: [invitationId], references: [id], onDelete: SetNull)
  invitationId String?
  actorName    String?          // Name of the person who triggered the notification
  createdAt    DateTime         @default(now())

  @@index([userId, read, createdAt])
  @@index([userId, createdAt])
}

enum NotificationType {
  INVITATION_RECEIVED
  INVITATION_ACCEPTED
  COMPACT_SIGNED
  SESSION_JOINED
  PARTNER_MESSAGE
  EMPATHY_SHARED
  NEEDS_SHARED
  AGREEMENT_PROPOSED
  AGREEMENT_CONFIRMED
  SESSION_RESOLVED
  FOLLOW_UP_REMINDER
  SESSION_ABANDONED
}

// ============================================================================
// User Memory (Things to Always Remember)
// ============================================================================

enum MemoryCategory {
  AI_NAME       // "Call me Alex"
  LANGUAGE      // "Respond in Spanish"
  COMMUNICATION // "Keep responses brief"
  PERSONAL_INFO // "Call me Sam", pronouns
  RELATIONSHIP  // "Partner's name is Jordan"
  PREFERENCE    // "Use examples when explaining"
}

enum MemoryStatus {
  ACTIVE
  REJECTED
}

enum MemorySource {
  USER_APPROVED // AI suggested, user approved
  USER_CREATED  // User created directly
  USER_EDITED   // AI suggested, user edited before saving
}

model UserMemory {
  id          String         @id @default(cuid())
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  session     Session?       @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId   String?        // null = global memory
  content     String         @db.Text
  category    MemoryCategory
  status      MemoryStatus   @default(ACTIVE)
  source      MemorySource   @default(USER_APPROVED)
  suggestedBy String?        @db.Text // AI's original suggestion if edited
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([userId, sessionId])
}
