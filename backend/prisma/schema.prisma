generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// ============================================================================
// Core Models
// ============================================================================

model User {
  id                       String    @id @default(cuid())
  clerkId                  String?   @unique // Clerk authentication user ID
  email                    String    @unique
  name                     String?   // Full name (computed from firstName + lastName)
  firstName                String?
  lastName                 String?
  pushToken                String?   // Expo push token for realtime fallbacks
  biometricEnabled         Boolean   @default(false)
  biometricEnrolledAt      DateTime?
  memoryPreferences        Json?     // MemoryPreferencesDTO - AI memory settings
  notificationPreferences  Json?     // NotificationPreferencesDTO - notification settings
  lastMoodIntensity        Int?      // Last mood intensity (1-10) for session entry default
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  // Relationships
  relationships       RelationshipMember[]
  vessels             UserVessel[]
  stageProgress       StageProgress[]
  messages            Message[]
  consentsGiven       ConsentRecord[]               @relation("ConsentsGiven")
  consentsRequested   ConsentRecord[]               @relation("ConsentsRequested")
  consentedContent    ConsentedContent[]
  empathyDrafts       EmpathyDraft[]
  empathyAttempts     EmpathyAttempt[]
  empathyValidations  EmpathyValidation[]
  strategyProposals   StrategyProposal[]
  strategyRankings    StrategyRanking[]
  exerciseCompletions EmotionalExerciseCompletion[]
  invitationsSent     Invitation[]                  @relation("InvitedBy")
  innerWorkSessions   InnerWorkSession[]
  notifications       Notification[]
  userMemories        UserMemory[]

  // Inner Work: Needs Assessment
  needScores          NeedScore[]
  needsAssessmentState NeedsAssessmentState?

  // Inner Work: People Tracking
  people              Person[]

  // Inner Work: Gratitude Practice
  gratitudeEntries    GratitudeEntry[]
  gratitudePreferences GratitudePreferences?

  // Inner Work: Meditation
  meditationSessions  MeditationSession[]
  meditationStats     MeditationStats?
  meditationFavorites MeditationFavorite[]
  meditationPreferences MeditationPreferences?
}

model Relationship {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Members (exactly 2 for Meet Without Fear)
  members  RelationshipMember[]
  sessions Session[]
}

model RelationshipMember {
  id             String       @id @default(cuid())
  relationship   Relationship @relation(fields: [relationshipId], references: [id], onDelete: Cascade)
  relationshipId String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  joinedAt       DateTime     @default(now())
  role           String       @default("member")
  nickname       String?      // What this member calls their partner

  @@unique([relationshipId, userId])
  @@index([userId])
}

// ============================================================================
// Session
// ============================================================================

model Session {
  id             String        @id @default(cuid())
  relationship   Relationship  @relation(fields: [relationshipId], references: [id], onDelete: Cascade)
  relationshipId String
  status         SessionStatus @default(CREATED)
  type           SessionType   @default(CONFLICT_RESOLUTION)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  resolvedAt     DateTime?

  // Related entities
  messages            Message[]
  sharedVessel        SharedVessel?
  stageProgress       StageProgress[]
  userVessels         UserVessel[]
  empathyDrafts       EmpathyDraft[]
  empathyAttempts     EmpathyAttempt[]
  empathyValidations  EmpathyValidation[]
  strategyProposals   StrategyProposal[]
  strategyRankings    StrategyRanking[]
  consentRecords      ConsentRecord[]
  exerciseCompletions EmotionalExerciseCompletion[]
  invitations         Invitation[]
  notifications       Notification[]
  userMemories        UserMemory[]

  // Linked Inner Thoughts sessions for private reflection during partner session
  linkedInnerThoughts InnerWorkSession[] @relation("LinkedInnerThoughts")

  @@index([relationshipId])
  @@index([status])
  @@index([type])
}

enum SessionType {
  CONFLICT_RESOLUTION // Partner-based conflict resolution (4-stage process)
  INNER_WORK // Solo self-reflection and pattern recognition
}

enum SessionStatus {
  CREATED // Invitation sent
  INVITED // Partner invited, awaiting join
  ACTIVE // Both users engaged
  PAUSED // Cooling period
  WAITING // One user ahead, waiting for other
  RESOLVED // Process completed
  ABANDONED // Timeout or withdrawal
  ARCHIVED // User has archived this session
}

// ============================================================================
// Inner Work Session (Solo Self-Reflection)
// ============================================================================

model InnerWorkSession {
  id        String              @id @default(cuid())
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  title     String?             // Optional user-provided or AI-generated title
  summary   String?             @db.Text // AI-generated summary of the session
  theme     String?             // Detected theme (e.g., "anxiety", "relationship patterns")
  status    InnerWorkStatus     @default(ACTIVE)
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  // Rolling conversation summary for long sessions (like partner session vessels)
  // Stores JSON: { text, keyThemes, emotionalJourney, unresolvedTopics, messageCount, generatedAt }
  conversationSummary String? @db.Text

  // Messages in this inner work session
  messages InnerWorkMessage[]

  // Link to partner session for context-aware Inner Thoughts
  // When set, AI has access to partner session context and can reference it
  linkedPartnerSession   Session? @relation("LinkedInnerThoughts", fields: [linkedPartnerSessionId], references: [id], onDelete: SetNull)
  linkedPartnerSessionId String?
  linkedAtStage          Int?     // Stage when Inner Thoughts was opened (1, 2, 3, 4)
  linkedTrigger          String?  // Why it was opened: "empathy_wait", "voluntary", "witness_wait"

  @@index([userId, updatedAt])
  @@index([status])
  @@index([linkedPartnerSessionId])
}

enum InnerWorkStatus {
  ACTIVE    // Ongoing inner work session
  COMPLETED // User marked as complete or AI determined closure
  ARCHIVED  // User archived this session
}

model InnerWorkMessage {
  id        String           @id @default(cuid())
  session   InnerWorkSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  role      MessageRole
  content   String           @db.Text
  timestamp DateTime         @default(now())

  // Embedding for semantic search and cross-session retrieval
  embedding Unsupported("vector(1024)")?

  @@index([sessionId, timestamp])
}

// ============================================================================
// Stage Progress
// ============================================================================

model StageProgress {
  id          String      @id @default(cuid())
  session     Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId   String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  stage       Int
  status      StageStatus @default(IN_PROGRESS)
  startedAt   DateTime    @default(now())
  completedAt DateTime?

  // Gate satisfaction tracking
  gatesSatisfied Json? // Stage-specific gate conditions

  // Synthesis cache invalidation
  isSynthesisDirty     Boolean   @default(true)
  synthesisLastUpdated DateTime?

  @@unique([sessionId, userId, stage])
  @@index([sessionId])
  @@index([userId])
}

enum StageStatus {
  NOT_STARTED
  IN_PROGRESS
  GATE_PENDING // Requirements met, awaiting partner
  COMPLETED
}

// ============================================================================
// User Vessel (Private Data)
// ============================================================================

model UserVessel {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Private content
  events            UserEvent[]
  emotionalReadings EmotionalReading[]
  identifiedNeeds   IdentifiedNeed[]
  boundaries        Boundary[]
  documents         UserDocument[]

  // Rolling conversation summary for long sessions
  // Stores JSON with: text, keyThemes, emotionalJourney, unresolvedTopics
  conversationSummary String? @db.Text

  // Embedding for semantic search within user's own content
  embedding Unsupported("vector(1024)")?

  @@unique([userId, sessionId])
  @@index([userId])
  @@index([sessionId])
}

model UserEvent {
  id           String      @id @default(cuid())
  vessel       UserVessel  @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId     String
  description  String      @db.Text
  attributedTo Attribution
  emotions     String[]
  timestamp    DateTime    @default(now())

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  @@index([vesselId, timestamp])
}

enum Attribution {
  SELF
  OTHER
  MUTUAL
  EXTERNAL
}

model EmotionalReading {
  id        String     @id @default(cuid())
  vessel    UserVessel @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId  String
  intensity Int // 1-10 scale
  context   String?    @db.Text
  stage     Int // Stage when reading was taken
  timestamp DateTime   @default(now())

  @@index([vesselId, timestamp])
}

model IdentifiedNeed {
  id           String       @id @default(cuid())
  vessel       UserVessel   @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId     String
  need         String // From universal needs taxonomy
  category     NeedCategory
  evidence     String[] // Quotes/references supporting this need
  confirmed    Boolean      @default(false) // User confirmed this need
  aiConfidence Float // AI confidence in identification
  createdAt    DateTime     @default(now())

  // Link to shared version if consented
  consentedContent ConsentedContent?

  @@index([vesselId])
}

enum NeedCategory {
  SAFETY
  CONNECTION
  AUTONOMY
  RECOGNITION
  MEANING
  FAIRNESS
}

model Boundary {
  id            String     @id @default(cuid())
  vessel        UserVessel @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId      String
  description   String     @db.Text
  nonNegotiable Boolean    @default(false)
  createdAt     DateTime   @default(now())

  @@index([vesselId])
}

model UserDocument {
  id        String     @id @default(cuid())
  vessel    UserVessel @relation(fields: [vesselId], references: [id], onDelete: Cascade)
  vesselId  String
  title     String
  content   String     @db.Text
  type      String // e.g., "reflection", "journal", "note"
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  @@index([vesselId])
}

// ============================================================================
// Shared Vessel (Consensual Data)
// ============================================================================

model SharedVessel {
  id        String   @id @default(cuid())
  session   Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Shared content
  consentedContent ConsentedContent[]
  commonGround     CommonGround[]
  agreements       Agreement[]
}

model ConsentedContent {
  id                 String          @id @default(cuid())
  sharedVessel       SharedVessel    @relation(fields: [sharedVesselId], references: [id], onDelete: Cascade)
  sharedVesselId     String
  sourceUser         User?           @relation(fields: [sourceUserId], references: [id], onDelete: SetNull)
  sourceUserId       String?
  originalNeed       IdentifiedNeed? @relation(fields: [originalNeedId], references: [id], onDelete: SetNull)
  originalNeedId     String?         @unique
  transformedContent String          @db.Text // Heat removed, need preserved
  consentedAt        DateTime        @default(now())
  consentActive      Boolean         @default(true)
  revokedAt          DateTime?

  // Link to consent record for audit
  consentRecord   ConsentRecord @relation(fields: [consentRecordId], references: [id])
  consentRecordId String

  @@index([sharedVesselId])
  @@index([sourceUserId])
}

model CommonGround {
  id             String       @id @default(cuid())
  sharedVessel   SharedVessel @relation(fields: [sharedVesselId], references: [id], onDelete: Cascade)
  sharedVesselId String
  need           String
  category       NeedCategory
  confirmedByA   Boolean      @default(false)
  confirmedByB   Boolean      @default(false)
  confirmedAt    DateTime?

  @@index([sharedVesselId])
}

model Agreement {
  id             String            @id @default(cuid())
  sharedVessel   SharedVessel      @relation(fields: [sharedVesselId], references: [id], onDelete: Cascade)
  sharedVesselId String
  description    String            @db.Text
  type           AgreementType
  status         AgreementStatus   @default(PROPOSED)
  agreedByA      Boolean           @default(false)
  agreedByB      Boolean           @default(false)
  agreedAt       DateTime?
  followUpDate   DateTime?
  completedAt    DateTime?
  proposal       StrategyProposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  proposalId     String?

  @@index([sharedVesselId])
}

enum AgreementType {
  MICRO_EXPERIMENT // Small, reversible action
  COMMITMENT // Longer-term agreement
  CHECK_IN // Scheduled follow-up
  HYBRID // Combined elements from multiple strategies
}

enum AgreementStatus {
  PROPOSED
  AGREED
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

// ============================================================================
// Consent Management
// ============================================================================

model ConsentRecord {
  id                String             @id @default(cuid())
  user              User               @relation("ConsentsGiven", fields: [userId], references: [id], onDelete: Cascade)
  userId            String
  session           Session?           @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId         String?
  targetType        ConsentContentType
  targetId          String? // e.g., empathy draft id, need id, boundary id
  requestedBy       User               @relation("ConsentsRequested", fields: [requestedByUserId], references: [id], onDelete: Cascade)
  requestedByUserId String
  decision          ConsentDecision?
  decidedAt         DateTime?
  revokedAt         DateTime?
  metadata          Json? // Additional context
  createdAt         DateTime           @default(now())

  // Link to resulting shared content
  consentedContent ConsentedContent[]
  empathyAttempt   EmpathyAttempt[]
  strategyProposal StrategyProposal[]

  @@index([userId, sessionId, targetType, decidedAt])
}

enum ConsentContentType {
  IDENTIFIED_NEED
  EVENT_SUMMARY
  EMOTIONAL_PATTERN
  BOUNDARY
  EMPATHY_DRAFT
  EMPATHY_ATTEMPT
  STRATEGY_PROPOSAL
}

enum ConsentDecision {
  GRANTED
  DENIED
  REVOKED
}

// ============================================================================
// Messages
// ============================================================================

model Message {
  id        String      @id @default(cuid())
  session   Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  sender    User?       @relation(fields: [senderId], references: [id], onDelete: SetNull)
  senderId  String? // null for AI messages
  forUserId String? // Which user the AI was responding to (for data isolation)
  role      MessageRole
  content   String      @db.Text
  stage     Int
  timestamp DateTime    @default(now())

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  // Extracted memory references
  extractedNeeds    String[]
  extractedEmotions String[]

  @@index([sessionId, timestamp])
  @@index([senderId])
  @@index([forUserId])
}

enum MessageRole {
  USER
  AI
  SYSTEM
  EMPATHY_STATEMENT     // User's shared empathy statement (shown in chat history)
  EMPATHY_REVEAL_INTRO  // AI intro message when revealing partner's empathy to user
  SHARED_CONTEXT        // Context shared by subject to help guesser refine empathy
  EMPATHY_VALIDATION_PROMPT // AI prompt asking user to validate partner's understanding
}

// ============================================================================
// Pre-Session Messages
// ============================================================================

// Messages captured before a session is created or identified.
// These are associated with a session retroactively once the user
// starts or switches to a session.
model PreSessionMessage {
  id        String      @id @default(cuid())
  userId    String
  role      MessageRole
  content   String      @db.Text
  timestamp DateTime    @default(now())

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  // Metadata from intent detection
  detectedIntent    String? // The intent detected for this message
  emotionalTone     String? // neutral, upset, hopeful, anxious
  extractedPerson   String? // If a person was mentioned
  extractedTopic    String? // If a topic was identified

  // Association tracking
  associatedSessionId String?   // Set when message is linked to a session
  associatedAt        DateTime? // When it was associated

  // Cleanup
  expiresAt DateTime // Auto-cleanup after 24 hours if not associated

  @@index([userId, timestamp])
  @@index([userId, associatedSessionId])
  @@index([expiresAt])
}

// ============================================================================
// Stage 2: Empathy Attempts
// ============================================================================

model EmpathyDraft {
  id           String   @id @default(cuid())
  session      Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId    String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  content      String   @db.Text
  readyToShare Boolean  @default(false)
  version      Int      @default(1)
  updatedAt    DateTime @updatedAt
  createdAt    DateTime @default(now())

  attempts EmpathyAttempt[]

  @@unique([sessionId, userId])
}

model EmpathyAttempt {
  id              String         @id @default(cuid())
  draft           EmpathyDraft?  @relation(fields: [draftId], references: [id], onDelete: SetNull)
  draftId         String?
  session         Session        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId       String
  sourceUser      User?          @relation(fields: [sourceUserId], references: [id], onDelete: SetNull)
  sourceUserId    String?
  content         String         @db.Text
  sharedAt        DateTime       @default(now())
  consentRecord   ConsentRecord? @relation(fields: [consentRecordId], references: [id], onDelete: SetNull)
  consentRecordId String?

  // Reconciler flow fields
  status        EmpathyStatus @default(HELD)
  revealedAt    DateTime?
  revisionCount Int           @default(0)

  validations EmpathyValidation[]

  @@index([sessionId, sourceUserId])
}

enum EmpathyStatus {
  HELD              // Waiting for partner to complete Stage 1
  ANALYZING         // Reconciler is comparing guess vs actual Stage 1 content
  AWAITING_SHARING  // Gaps detected, waiting for subject to respond to share suggestion
  REFINING          // Guesser is refining after receiving shared context
  NEEDS_WORK        // Significant gaps detected, guesser should refine (legacy - use AWAITING_SHARING)
  REVEALED          // Recipient can now see statement
  VALIDATED         // Recipient has validated accuracy
}

model EmpathyValidation {
  id             String         @id @default(cuid())
  attempt        EmpathyAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  attemptId      String
  session        Session        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId      String
  user           User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId         String? // Recipient validating partner attempt (null if user deleted)
  validated      Boolean
  feedback       String?        @db.Text
  feedbackShared Boolean        @default(false)
  validatedAt    DateTime?      @default(now())

  @@unique([attemptId, userId])
}

// ============================================================================
// Post-Stage 2: Empathy Reconciler
// ============================================================================

/// Stores the result of reconciler analysis comparing what one person
/// guessed about the other vs what they actually expressed.
model ReconcilerResult {
  id        String   @id @default(cuid())
  sessionId String

  /// The user who made the empathy guess
  guesserId     String
  guesserName   String
  /// The user being guessed about (whose feelings were analyzed)
  subjectId     String
  subjectName   String

  // Alignment Analysis
  alignmentScore     Int      // 0-100
  alignmentSummary   String   @db.Text
  correctlyIdentified String[] // Feelings/needs that were correctly identified

  // Gap Analysis
  gapSeverity       String   // none, minor, moderate, significant
  gapSummary        String   @db.Text
  missedFeelings    String[] // Feelings/needs that were missed
  misattributions   String[] // Incorrect assumptions made
  mostImportantGap  String?  @db.Text // The single most important gap

  // Recommendation
  recommendedAction   String  // PROCEED, OFFER_OPTIONAL, OFFER_SHARING
  rationale           String  @db.Text
  sharingWouldHelp    Boolean
  suggestedShareFocus String? @db.Text

  // Abstract guidance for refinement (no specific partner content)
  areaHint      String?   // e.g., "work and effort"
  guidanceType  String?   // e.g., "explore_deeper_feelings"
  promptSeed    String?   // e.g., "what might be underneath"

  // Suggestion for subject to share (generated when gaps are significant)
  suggestedShareContent String?  @db.Text  // AI-generated suggestion for what subject could share
  suggestedShareReason  String?  @db.Text  // Why this would help the guesser understand

  createdAt DateTime @default(now())

  // Relationship to share offer
  shareOffer ReconcilerShareOffer?

  @@unique([sessionId, guesserId, subjectId])
  @@index([sessionId])
}

/// Tracks the share suggestion made to a user (the subject) and their response.
/// This allows the subject to optionally share context to help the guesser understand better.
model ReconcilerShareOffer {
  id        String   @id @default(cuid())
  result    ReconcilerResult @relation(fields: [resultId], references: [id], onDelete: Cascade)
  resultId  String   @unique

  /// The user being asked to share (the subject of the analysis)
  userId    String

  /// Status of the share offer
  status    ReconcilerShareStatus @default(NOT_OFFERED)

  /// AI-generated suggestion for what to share
  suggestedContent   String?  @db.Text  // What the AI suggests the subject could share
  suggestedReason    String?  @db.Text  // Why this would help the guesser

  /// The AI-generated message offering to share (shown to user)
  offerMessage      String?  @db.Text

  /// Quote options extracted from their witnessing (legacy, may be removed)
  quoteOptions      Json?    // Array of QuoteOption objects
  recommendedQuote  Int?     // Index of recommended quote

  /// User's refined version (if they edited the suggestion)
  refinedContent     String?  @db.Text

  /// Final content that was shared (could be suggested, refined, or custom)
  sharedContent     String?  @db.Text
  sharedAt          DateTime?

  /// If they declined
  declinedAt        DateTime?

  /// Legacy: skipped without responding
  skippedAt         DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status])
}

enum ReconcilerShareStatus {
  PENDING     // Suggestion generated, not yet shown to user
  OFFERED     // Shown to user, awaiting response
  ACCEPTED    // User accepted (with or without refinement)
  DECLINED    // User declined to share
  EXPIRED     // Offer expired (timeout)
  NOT_OFFERED // Legacy: no offer was made
  SKIPPED     // Legacy: user skipped without responding
}

// ============================================================================
// Stage 4: Strategies and Rankings
// ============================================================================

model StrategyProposal {
  id               String         @id @default(cuid())
  session          Session        @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId        String
  createdBy        User?          @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdByUserId  String?
  description      String         @db.Text
  needsAddressed   String[]
  duration         String?
  measureOfSuccess String?
  source           StrategySource @default(USER_SUBMITTED)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  consentRecord    ConsentRecord? @relation(fields: [consentRecordId], references: [id], onDelete: SetNull)
  consentRecordId  String?

  // Note: Rankings reference proposals via rankedIds (String[]), not a direct relation
  agreements Agreement[]

  @@index([sessionId])
}

enum StrategySource {
  USER_SUBMITTED
  AI_SUGGESTED
  CURATED
}

model StrategyRanking {
  id          String   @id @default(cuid())
  session     Session  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId   String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  rankedIds   String[] // Ordered StrategyProposal ids
  submittedAt DateTime @default(now())

  @@unique([sessionId, userId])
}

// ============================================================================
// Emotional Regulation
// ============================================================================

model EmotionalExerciseCompletion {
  id              String       @id @default(cuid())
  session         Session      @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId       String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  type            ExerciseType
  completedAt     DateTime     @default(now())
  intensityBefore Int?
  intensityAfter  Int?

  @@index([sessionId, userId, completedAt])
}

enum ExerciseType {
  BREATHING_EXERCISE
  BODY_SCAN
  GROUNDING
  PAUSE_SESSION
}

// ============================================================================
// Global Library (Stage 4 Suggestions)
// ============================================================================

model GlobalLibraryItem {
  id          String              @id @default(cuid())
  title       String
  description String              @db.Text
  category    String // e.g., "communication", "quality-time", "conflict-resolution"
  source      GlobalLibrarySource
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  // For user-contributed items only
  contributedBy       String? // User ID if contributed (anonymized in results)
  contributionConsent DateTime? // When user consented to anonymized contribution

  @@index([category])
  @@index([source])
}

enum GlobalLibrarySource {
  CURATED // Admin/expert authored
  CONTRIBUTED // User-contributed with explicit consent
}

// ============================================================================
// Invitations
// ============================================================================

model Invitation {
  id                String           @id @default(cuid())
  session           Session          @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId         String
  invitedBy         User             @relation("InvitedBy", fields: [invitedById], references: [id], onDelete: Cascade)
  invitedById       String
  name              String?          // Display name for the invited person
  invitationMessage   String?          @db.Text // The crafted invitation message
  messageConfirmed    Boolean          @default(false) // User confirmed the message
  messageConfirmedAt  DateTime?        // When the user confirmed the message (for chat indicator positioning)
  status              InvitationStatus @default(PENDING)
  createdAt         DateTime         @default(now())
  expiresAt         DateTime
  acceptedAt        DateTime?
  declinedAt        DateTime?
  declineReason     String?
  notifications     Notification[]

  @@index([sessionId])
  @@index([status])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

// ============================================================================
// Notifications
// ============================================================================

model Notification {
  id           String           @id @default(cuid())
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  type         NotificationType
  title        String
  body         String           @db.Text
  read         Boolean          @default(false)
  session      Session?         @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  sessionId    String?
  invitation   Invitation?      @relation(fields: [invitationId], references: [id], onDelete: SetNull)
  invitationId String?
  actorName    String?          // Name of the person who triggered the notification
  createdAt    DateTime         @default(now())

  @@index([userId, read, createdAt])
  @@index([userId, createdAt])
}

enum NotificationType {
  INVITATION_RECEIVED
  INVITATION_ACCEPTED
  COMPACT_SIGNED
  SESSION_JOINED
  PARTNER_MESSAGE
  EMPATHY_SHARED
  EMPATHY_REVEALED      // Partner's empathy statement is now visible to you
  EMPATHY_NEEDS_WORK    // Your empathy statement needs refinement
  EMPATHY_VALIDATED     // Partner validated your empathy statement as accurate
  NEEDS_SHARED
  AGREEMENT_PROPOSED
  AGREEMENT_CONFIRMED
  SESSION_RESOLVED
  FOLLOW_UP_REMINDER
  SESSION_ABANDONED
}

// ============================================================================
// User Memory (Things to Always Remember)
// ============================================================================

enum MemoryCategory {
  AI_NAME       // "Call me Alex"
  LANGUAGE      // "Respond in Spanish"
  COMMUNICATION // "Keep responses brief"
  PERSONAL_INFO // "Call me Sam", pronouns
  RELATIONSHIP  // "Partner's name is Jordan"
  PREFERENCE    // "Use examples when explaining"
}

enum MemoryStatus {
  ACTIVE
  PENDING
  REJECTED
}

enum MemorySource {
  USER_APPROVED // AI suggested, user approved
  USER_CREATED  // User created directly
  USER_EDITED   // AI suggested, user edited before saving
}

model UserMemory {
  id          String         @id @default(cuid())
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  session     Session?       @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId   String?        // null = global memory
  content     String         @db.Text
  category    MemoryCategory
  status      MemoryStatus   @default(ACTIVE)
  source      MemorySource   @default(USER_APPROVED)
  suggestedBy String?        @db.Text // AI's original suggestion if edited
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([userId, sessionId])
}

// ============================================================================
// Inner Work: Needs Assessment ("Am I OK?")
// ============================================================================

// Reference table for the 19 core human needs (seeded data)
model Need {
  id          Int          @id
  name        String       // "Physical Safety"
  slug        String       @unique // "physical-safety"
  description String       @db.Text // Full question text
  category    NeedsCategory
  order       Int          // Display order within category

  scores NeedScore[]
}

enum NeedsCategory {
  FOUNDATION    // Physical safety, health, rest, material security
  EMOTIONAL     // Emotional safety, self-compassion, regulation, agency
  RELATIONAL    // Being seen, belonging, trust, contribution
  INTEGRATION   // Purpose, learning, integrity, hope
  TRANSCENDENCE // Presence, gratitude, connection to larger whole
}

// User's scores over time for each need
model NeedScore {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  need          Need     @relation(fields: [needId], references: [id], onDelete: Cascade)
  needId        Int
  score         Int      // 0 = Not met, 1 = Somewhat met, 2 = Fully met
  clarification String?  @db.Text // Optional user notes
  createdAt     DateTime @default(now())

  @@index([userId, needId])
  @@index([userId, createdAt])
}

// Track baseline completion and check-in preferences
model NeedsAssessmentState {
  id                   String    @id @default(cuid())
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String    @unique
  baselineCompleted    Boolean   @default(false)
  baselineCompletedAt  DateTime?
  checkInFrequencyDays Int       @default(7) // 1-10 days
  lastCheckInNeedId    Int?      // Which need was last checked
  lastCheckInAt        DateTime?
  nextCheckInAt        DateTime?
}

// ============================================================================
// Inner Work: People Tracking
// ============================================================================

// A person mentioned by the user across features
model Person {
  id             String   @id @default(cuid())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  name           String   // Primary name: "Sarah"
  aliases        String[] @default([]) // ["my friend Sarah", "Sarah W."]
  relationship   String?  // "friend", "partner", "family", "coworker", etc.
  firstMentioned DateTime @default(now())
  lastMentioned  DateTime @default(now())

  // Mention counts by feature
  mentionCountInnerThoughts Int @default(0)
  mentionCountGratitude     Int @default(0)
  mentionCountNeeds         Int @default(0)
  mentionCountConflict      Int @default(0) // Partner sessions

  // Which needs this person relates to (JSON: { "trust": 3, "belonging": 1 })
  needsConnections Json @default("{}")

  mentions PersonMention[]

  @@unique([userId, name])
  @@index([userId, lastMentioned])
}

// Individual mention instance
model PersonMention {
  id         String            @id @default(cuid())
  person     Person            @relation(fields: [personId], references: [id], onDelete: Cascade)
  personId   String
  userId     String
  sourceType MentionSourceType
  sourceId   String            // ID of the source entity
  context    String?           @db.Text // Surrounding text snippet
  sentiment  Float?            // -1 to 1
  createdAt  DateTime          @default(now())

  @@index([personId, createdAt])
  @@index([userId, sourceType])
}

enum MentionSourceType {
  INNER_THOUGHTS  // InnerWorkMessage
  GRATITUDE       // GratitudeEntry
  NEEDS_CHECKIN   // NeedScore clarification
  PARTNER_SESSION // Session message
}

// ============================================================================
// Inner Work: Gratitude Practice ("See the Positive")
// ============================================================================

model GratitudeEntry {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  content       String   @db.Text // The gratitude text
  voiceRecorded Boolean  @default(false)
  createdAt     DateTime @default(now())

  // AI-extracted metadata (populated async)
  extractedPeople     String[] @default([])
  extractedPlaces     String[] @default([])
  extractedActivities String[] @default([])
  extractedEmotions   String[] @default([])
  extractedThemes     String[] @default([])

  // Connections
  linkedNeedIds    Int[]   @default([]) // Which needs this touches
  linkedConflictId String? // If mentioned an active conflict
  sentimentScore   Float?  // -1 to 1, for trend tracking

  // AI response to the gratitude
  aiResponse String? @db.Text

  // Embedding for semantic search
  embedding Unsupported("vector(1024)")?

  @@index([userId, createdAt])
}

// User preferences for gratitude practice
model GratitudePreferences {
  id              String   @id @default(cuid())
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String   @unique
  enabled         Boolean  @default(true)
  frequency       Int      @default(1) // 0-3 times per day
  preferredTimes  String[] @default(["20:00"]) // Array of HH:MM
  weekdayOnly     Boolean  @default(false)
  quietHoursStart String?  // HH:MM
  quietHoursEnd   String?  // HH:MM
}

// ============================================================================
// Inner Work: Meditation ("Develop Loving Awareness")
// ============================================================================

model MeditationSession {
  id              String         @id @default(cuid())
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  type            MeditationType
  durationMinutes Int
  focusArea       String?        // e.g., "grounding", "self-compassion"
  completed       Boolean        @default(false)
  startedAt       DateTime       @default(now())
  completedAt     DateTime?

  // Guided-specific
  scriptGenerated String? @db.Text // Full script text
  voiceId         String? // TTS voice identifier
  backgroundSound String? // "rain", "bowls", "silence"

  // Favorites
  savedAsFavorite Boolean       @default(false)
  favoriteType    FavoriteType?

  // Post-session
  postNotes        String? @db.Text
  linkedNeedIds    Int[]   @default([])
  linkedConflictId String? // If done in preparation for conflict

  @@index([userId, startedAt])
}

enum MeditationType {
  GUIDED
  UNGUIDED
}

enum FavoriteType {
  EXACT // Replay exact script
  THEME // Generate fresh variation
}

// Aggregated stats (computed on save)
model MeditationStats {
  id              String    @id @default(cuid())
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String    @unique
  totalSessions   Int       @default(0)
  guidedCount     Int       @default(0)
  unguidedCount   Int       @default(0)
  totalMinutes    Int       @default(0)
  currentStreak   Int       @default(0)
  longestStreak   Int       @default(0)
  streakStartDate DateTime?
  lastSessionDate DateTime?

  // Favorite focus areas (JSON: { "grounding": 5, "compassion": 3 })
  favoriteFocusAreas Json @default("{}")
}

// Saved meditation favorites
model MeditationFavorite {
  id              String       @id @default(cuid())
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  name            String       // User-given or auto-generated name
  focusArea       String
  durationMinutes Int
  favoriteType    FavoriteType
  script          String?      @db.Text // Only for EXACT type
  savedAt         DateTime     @default(now())

  @@index([userId])
}

// User preferences for meditation
model MeditationPreferences {
  id              String  @id @default(cuid())
  user            User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String  @unique
  preferredVoice  String  @default("default")
  voiceSpeed      Float   @default(1.0) // 0.8 - 1.2
  defaultDuration Int     @default(10)
  backgroundSound String  @default("silence")
  reminderEnabled Boolean @default(false)
  reminderTime    String? // HH:MM
}

// ============================================================================
// Core System
// ============================================================================

model AuditLog {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())
  section   String   // AuditSection enum string
  message   String   @db.Text
  turnId    String?
  sessionId String?
  data      Json?
  cost      Float?
  
  @@index([sessionId])
  @@index([turnId])
  @@index([timestamp])
}
